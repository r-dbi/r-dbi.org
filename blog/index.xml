<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>R-DBI</title>
<link>https://r-dbi.org/blog/</link>
<atom:link href="https://r-dbi.org/blog/index.xml" rel="self" type="application/rss+xml"/>
<description>R + databases</description>
<generator>quarto-1.6.15</generator>
<lastBuildDate>Sun, 14 Apr 2024 00:00:00 GMT</lastBuildDate>
<item>
  <title>Using Arrow for data transport</title>
  <dc:creator>Kirill M√ºller</dc:creator>
  <link>https://r-dbi.org/blog/dbi-4-3/</link>
  <description><![CDATA[ 




<p>The third and final blog post explores the new Arrow Database Connectivity (ADBC) project, which provides a common interface for database access across ecosystems and database systems, using the Arrow data format as data exchange format. The associated R bindings available from the adbcdrivermanager package provide the foundation for the adbi package, bridging the gap between ADBC and DBI, and thereby enabling existing code that uses DBI to seamlessly interact with the new ADBC drivers.</p>
<p><em>This is a continuation of the <a href="https://r-dbi.org/blog/dbi-4-1/">first</a> and <a href="https://r-dbi.org/blog/dbi-4-2/">second blog post</a> in this series.</em></p>
<section id="a-new-database-standard" class="level2">
<h2 class="anchored" data-anchor-id="a-new-database-standard">A new database standard?</h2>
<p>The DBI package offers consistent database access in R. Different database systems, such as PostgreSQL, MySQL, SQLite, and others, can be accessed through a common interface. To access a particular database, a driver package is required, such as RMariaDB, RPostgres, or RSQLite. These driver packages implement the DBI interface and bind to the database system‚Äôs native client library, such as Connector/C for MariaDB or libpq for PostgreSQL. A common interface is essential for users who want to switch between database systems or who want to use different database systems in the same project. Similar efforts exist in other ecosystems, such as Python‚Äôs DB-API 2.0. When considering the bigger picture, providing access to all databases for all ecosystems looks like this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://r-dbi.org/blog/dbi-4-3/pairwise.png" class="img-fluid figure-img" alt="Two boxes, Databases at the top, ecosystems at the bottom. PostgreSQL, SQL Server, MariaDB, Oracle, Clickhouse in the top box, R, Python, Julia, Excel, Tableau, and others in the bottom box. One arrow from each database to each ecosystem."></p>
<figcaption>Direct access to all databases from all ecosystems</figcaption>
</figure>
</div>
<p>Each line represents a software package to develop and maintain, following changes in the database system and the target ecosystem. And, of course, the list of databases and ecosystems is not exhaustive. With every new system, many more connections need to be established. A daunting task!</p>
<p>This is where the ADBC project comes in. The <a href="https://arrow.apache.org/adbc/">Arrow Database Connectivity</a> project aims to provide a common interface for database access across ecosystems, using the Arrow data format as data exchange format. This way, the above graphic can be simplified:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://r-dbi.org/blog/dbi-4-3/star.png" class="img-fluid figure-img" alt="Two boxes, Databases at the top, ecosystems at the bottom. PostgreSQL, SQL Server, MariaDB, Oracle, Clickhouse in the top box, R, Python, Julia, Excel, Tableau, and others in the bottom box. ADBC in the middle, with one arrow from each database to ADBC and from ADBC to each ecosystem."></p>
<figcaption>Access to all databases from all ecosystems through ADBC</figcaption>
</figure>
</div>
<p>This isn‚Äôt an <a href="https://xkcd.com/927/">entirely new idea</a>. ODBC (Open Database Connectivity) and JDBC (Java Database Connectivity) have been around for a long time, with very similar goals. The new implementation can build on the lessons learned from these projects. The standardization around the Arrow data format is a significant advantage:</p>
<ul>
<li><p>Most data types typically supported by databases are supported directly, and the format is extensible.</p></li>
<li><p>The same data format can be used across ecosystems, avoiding conversions and copies.</p></li>
<li><p>Arrow is designed for high performance, with zero-copy data sharing between systems, with good support for both columnar and row-oriented data processing.</p></li>
<li><p>With FlightSQL, the same data format can be used for data exchange between client and server, avoiding serialization and deserialization.</p></li>
<li><p>Like with ODBC, an ADBC driver is a shared library that can be loaded into any ecosystem. In addition, ADBC drivers can be tightly coupled with the target system, allowing to cover database-specific functionality that is not part of ADBC. An example is adbcpostgresql, which provides access to PostgreSQL-specific features: it exists as a <a href="https://github.com/apache/arrow-adbc/tree/main/c/driver/postgresql">standalone C library</a>, as an <a href="https://github.com/apache/arrow-adbc/tree/main/r/adbcpostgresql">R package</a> (essentially vendoring the C library with some very lightweight boilerplate), as a <a href="https://github.com/apache/arrow-adbc/tree/main/python/adbc_driver_postgresql">Python package</a>, and for many other target ecosystems. This greatly simplifies the installation and configuration of the driver.</p></li>
</ul>
<p>For R, the main entry point is the <a href="https://arrow.apache.org/adbc/current/r/adbcdrivermanager/">adbcdrivermanager package</a>. It provides the glue between R and the ADBC drivers. Because all ADBC drivers use the same Arrow data format, the adbcdrivermanager package can focus on the common functionality, such as connection management, query execution, and data retrieval. For example, the <a href="https://arrow.apache.org/adbc/current/r/adbcpostgresql/">adbcpostgresql package</a> imports the adbcdrivermanager package and provides the PostgreSQL-specific functionality, with currently very few additional features.</p>
</section>
<section id="the-adbi-package" class="level2">
<h2 class="anchored" data-anchor-id="the-adbi-package">The adbi package</h2>
<p>Because ADBC is a new project, it doesn‚Äôt yet cover all databases and ecosystems. To simplify the transition, the adbi package bridges ADBC drivers and DBI, enabling existing code that uses DBI to seamlessly interact with the new ADBC drivers. Thanks to <a href="https://voltrondata.com/">Voltron Data</a> for the collaboration on this project and for the support in developing the adbi package and the DBI extension.</p>
<p>The adbi package is available on CRAN and provides the following features:</p>
<ul>
<li><p>Access to ADBC drivers through the DBI interface.</p></li>
<li><p>Data retrieval as data frames or Arrow, side by side, on the same connection object, using the new generics defined by DBI.</p></li>
</ul>
<p>The DBI package provides a default implementation for the new Arrow generics, which is not optimized for performance but can be used to directly convert data provided by DBI backends to Arrow. However, by using adbi with the new DBI generics such as <code>dbGetQueryArrow()</code> or <code>dbFetchArrow()</code>, the data is never converted to a data frame, and the Arrow data format is used directly. See <a href="https://r-dbi.org/blog/dbi-4-1/#integration-with-arrow">the relevant section in the first blog post</a> for an example using PostgreSQL.</p>
</section>
<section id="reimagining-dbi" class="level2">
<h2 class="anchored" data-anchor-id="reimagining-dbi">Reimagining DBI</h2>
<p>The <a href="https://github.com/r-dbi/dbi3/">dbi3 repository</a> currently only hosts an issue tracker and a couple of scripts. Several issues were moved from other repositories in the <a href="https://github.com/r-dbi">r-dbi organization</a>, with the intention of shaping the reimagining of a more modern database interface. With the new ADBC standard and the adbi package, it seemed worthwhile to revisit the responsibilities of a database interface in R.</p>
<p>The <a href="https://github.com/r-dbi/dbi3?tab=readme-ov-file#issues-and-solutions">README</a> now contains a categorization of the issues. It turns out that roughly a third of the issues can be addressed with ADBC and the adbcdrivermanager package, or a solution building on ADBC/adbcdrivermanager. Another thrid of the issues seem to belong in other packages such as dbplyr or dm. The the final third are issues that are not actionable at this time. The way forward therefore depends to a large extent on whether the ADBC project will be successful and whether the R community will adopt it. To help with this, DBI will keep and improve compatibility with ADBC and adbi.</p>
<p>To bring adbcdrivermanager on par with DBI, a few issues need to be addressed:</p>
<ul>
<li><p>SQL generation: how can dbplyr be connected to ADBC, either directly or via adbi?</p></li>
<li><p>Usability: the adbcdrivermanager package looks more like an ‚Äúimplementer‚Äôs interface‚Äù, a convenience ‚Äúuser‚Äôs interface‚Äù wrapper or extension might make it easier to use. More on that below.</p></li>
<li><p>Test suite: should a test package similarly to DBItest be created?</p></li>
<li><p>Interoperability with existing DBI backends: can a generic ADBC driver be created so that any existing DBI backend can be used with ADBC? A prime candidate would be the odbc package, this would add support for all ODBC drivers to ADBC via R, until a native ADBC driver is available.</p></li>
<li><p>Documentation: the ADBC standard is well-documented, but the documentation specific to the R ecosystem could be expanded.</p></li>
</ul>
</section>
<section id="bindings-database-user-interface" class="level2">
<h2 class="anchored" data-anchor-id="bindings-database-user-interface">Bindings, database, user interface</h2>
<p>Let‚Äôs step back a little to better understand the responsibilities of DBI and the various other components. What is core functionality, what can be provided by addon packages, and what use cases should be left for the end user to implement?</p>
<p>As an R user, I need to:</p>
<ul>
<li><p>connect to a database,</p></li>
<li><p>run a query,</p></li>
<li><p>read the resulting table,</p></li>
<li><p>create a new table,</p></li>
<li><p>write data to a table.</p></li>
</ul>
<p>I might also need to:</p>
<ul>
<li><p>create complex queries that involve multiple tables,</p></li>
<li><p>access metadata such as table and column names, column types, etc.,</p></li>
<li><p>read data asynchronously.</p></li>
</ul>
<p>The adbcdrivermanager package with the ADBC drivers tick almost all boxes from the ‚ÄúI need to‚Äù list, but none of the boxes from the ‚ÄúI might also need to‚Äù list. It does so by focusing on the following functionality:</p>
<ul>
<li><p>simple connect and disconnect based on credentials,</p></li>
<li><p>data type mapping between Arrow and the native database driver,</p></li>
<li><p>data transfer in both directions,</p></li>
<li><p>execution of queries, with support for placeholders,</p></li>
<li><p>reporting success or failure of queries and other operations.</p></li>
</ul>
<p>This shows a good separation of concerns: the adbcdrivermanager package provides the core functionality (‚Äúbindings‚Äù), and other code can build on top of that to provide more advanced features (‚Äúuser interface‚Äù).</p>
<p>The bindings alone are not enough to provide a good user experience. As an example, there are now several ways to access a PostgreSQL database from R:</p>
<ul>
<li><p>Use the RPostgres or RPostgreSQL packages, which provide a DBI backend for PostgreSQL.</p></li>
<li><p>Use the adbcpostgresql package, which provides an ADBC driver for PostgreSQL.</p></li>
<li><p>Use the adbi package, which provides a DBI backend for ADBC that allows accessing PostgreSQL through its ADBC driver.</p></li>
<li><p>Use the odbc package, which provides a DBI backend for ODBC that allows accessing PostgreSQL through an ODBC driver.</p></li>
</ul>
<p>In the past, ‚Äúdatabase driver‚Äù and ‚Äúdatabase‚Äù were often used interchangeably. Some of the operations required to effectively work with a database (such as listing the available tables) are currently tightly coupled with the database driver, but would be best handled by a separate component that dispatches by database. As long as the database driver <a href="https://github.com/paleolimbot/demoadbcplyr/pull/2#issuecomment-2059209643">reports on the kind of database</a>, from which the SQL dialect could be inferred, other components can handle the remaining tasks. Specifically:</p>
<ul>
<li><p>To write complex queries that involve multiple tables, dbplyr can dispatch on the SQL dialect and generate the appropriate SQL code.</p></li>
<li><p>To review and manage the tables in our database, the dm package has a concept of a standardized ‚Äúmeta-database‚Äù, similarly to <code>INFORMATION_SCHEMA</code> in SQL. (It is currently only used <a href="https://github.com/cynkra/dm/blob/e52ba91e26b04a0332039f8754054cb246542f7e/R/meta.R">internally</a>, but could be exposed.)</p></li>
<li><p>To efficiently access a database from a Shiny app, without blocking the user interface or other sessions handled by the same R process on the server, a helper that wraps ADBC‚Äôs low-level asynchronous support as <a href="https://rstudio.github.io/promises/">promises</a> would be most helpful.</p></li>
<li><p>The combination of bindings and database meta-information should be sufficient to satisfy virtually all other use cases across all databases. In cases where the bindings must provide a functionality that cannot be achieved through the query mechanism, ADBC makes it easy to extend the driver packages (such as the adbcpostgresql R package).</p></li>
</ul>
<p>In contrast, in DBI, the three concepts ‚Äúbindings‚Äù, ‚Äúdatabase‚Äù, and ‚Äúuser interface‚Äù are conflated. Disentangling them now will be hard.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>With the implementation of adbi and the new DBI generics, the foundation for adopting ADBC has been laid. To future-proof ADBC and adbcdrivermanager, a good exercise might be to attempt implementing dbplyr for ADBC connection building directly on adbcdrivermanager, bypassing DBI. This will uncover missing pieces and clarify what kind of utilities is needed to make it a pleasant exercise to work with databases through ADBC in R. DBI will remain supported, but new development will be restricted to supporting the ‚ÄúI need to‚Äù list above.</p>
<p>Does the adbi package work for you? What would a good ‚Äúuser interface‚Äù package look like for ADBC? Use the <a href="https://github.com/r-dbi/adbi/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc">adbi issue tracker</a> to get in touch!</p>
<p>Thanks to Ma√´lle Salmon (<a href="https://github.com/maelle">@maelle</a>) and Nicolas Bennett (<a href="https://github.com/nbenn">@nbenn</a>) for their help with the blog post, and to <a href="https://voltrondata.com/">Voltron Data</a> for supporting this effort.</p>
<!--
TODO: Bump DBItest

TODO: CRAN release

TODO: Post in rOpenSci slack
-->


</section>

 ]]></description>
  <guid>https://r-dbi.org/blog/dbi-4-3/</guid>
  <pubDate>Sun, 14 Apr 2024 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Towards sustainable DBI maintenance</title>
  <dc:creator>Kirill M√ºller</dc:creator>
  <link>https://r-dbi.org/blog/dbi-4-2/</link>
  <description><![CDATA[ 




<p>For 2022 and 2023, no concrete new features were planned. Instead, the focus has been on establishing a sustainable and steady pace of maintenance and responsiveness to user feedback. This blog post shows how we have been doing in this regard.</p>
<p><em>This is a continuation of the <a href="https://r-dbi.org/blog/dbi-4-1/">first blog post</a> in this series.</em></p>
<p>This analysis is based on the GitHub issues opened in the r-dbi organization since development has moved to GitHub, for the following packages: DBI, DBItest, RMariaDB, RPostgres, RSQLite, dblog, RKazam. See <a href="https://github.com/r-dbi/issues/" class="uri">https://github.com/r-dbi/issues/</a> for the source of the analysis.</p>
<p>In total, 2086 issues and pull requests were opened in the package repositories, of which 462 were opened in 2022 or later.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://r-dbi.org/blog/dbi-4-2/issues_per_year.png" class="img-fluid figure-img"></p>
<figcaption>Issues opened per year</figcaption>
</figure>
</div>
<p>The bar chart shows the number of issues opened per year. In recent years, the vast majority of the issues were opened by contributors and non-members.</p>
<p>To analyze responsiveness, we consider the time it takes from opening an issue by a non-member to the first response by a member, and to closing the issue.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://r-dbi.org/blog/dbi-4-2/time_to_first_response.png" class="img-fluid figure-img"></p>
<figcaption>Time to first member comment</figcaption>
</figure>
</div>
<p>Responsiveness to issues has improved, the majority of issues are now responded to within a single day. Unfortunately, some issues still required more than two weeks until the first response. The situation is similar for pull requests: Some are reviewed within a few days, but others remain unreviewed for more than two weeks.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://r-dbi.org/blog/dbi-4-2/time_to_close.png" class="img-fluid figure-img"></p>
<figcaption>Time to close issues</figcaption>
</figure>
</div>
<p>The time to close issues varies too. Many can be closed within a day or a week, but some issues remain open for months or even years. For PRs, it depends whether they were created by CI/CD or by a human. Autogenerated PRs tend to get merged or closed much faster, but the general pattern is similar to issues.</p>
<section id="moving-forward" class="level2">
<h2 class="anchored" data-anchor-id="moving-forward">Moving forward</h2>
<p>Unfortunately, I‚Äôm using RPostgres, RMariaDB and RSQLite only in a lab setting, not in production. The new <a href="https://github.com/r-dbi/docker">docker</a> repository is a step towards making it easier to test various combinations of database servers and client libraries. I hope that this will make it easier to experience what using these tools in production is like, perhaps in combination with <a href="https://medium.com/@kazushi/simulate-high-latency-network-using-docker-containerand-tc-commands-a3e503ea4307">increasing network latency</a> and <a href="https://www.sitespeed.io/documentation/throttle/">throttling bandwidth</a>.</p>
<p>No lab setup can replace the experience of using these tools in production. To effectively maintain DBI and the backend packages, I rely on contributed issues and pull requests. I‚Äôm grateful for every issue opened, even if some may be not actionable for me. Luckily, for a substantial number of the issues, the first response actally comes from a contributor! If you are interested in helping out, consider <a href="https://docs.github.com/en/account-and-profile/managing-subscriptions-and-notifications-on-github/setting-up-notifications/configuring-notifications#configuring-your-watch-settings-for-an-individual-repository">watching</a> one or several repositories in the <a href="https://github.com/r-dbi/">r-dbi organization</a>.</p>
<p>Thanks to Ma√´lle Salmon (<a href="https://github.com/maelle">@maelle</a>) and Nicolas Bennett (<a href="https://github.com/nbenn">@nbenn</a>) for their help with the blog post.</p>


</section>

 ]]></description>
  <guid>https://r-dbi.org/blog/dbi-4-2/</guid>
  <pubDate>Sun, 07 Apr 2024 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Recent improvements</title>
  <dc:creator>Kirill M√ºller</dc:creator>
  <link>https://r-dbi.org/blog/dbi-4-1/</link>
  <description><![CDATA[ 




<section id="what-is-dbi" class="level2">
<h2 class="anchored" data-anchor-id="what-is-dbi">What is DBI?</h2>
<p>The <a href="https://dbi.r-dbi.org/">DBI package</a> (<strong>d</strong>ata<strong>b</strong>ase <strong>i</strong>nterface) is a layer between R and database management systems (DBMSes). Users who interact with DBMSes via the DBI package are able to use the same API for all DBMSes. Implementations of this API are provided by DBMS-specific <a href="https://github.com/r-dbi/backends#readme">backend packages</a>, such as <a href="https://rpostgres.r-dbi.org/">RPostgres</a>, <a href="https://rmariadb.r-dbi.org/">RMariaDB</a>, and <a href="https://rsqlite.r-dbi.org/">RSQLite</a>. If you are new to DBI, you can find a good entry point in the <a href="https://dbi.r-dbi.org/articles/DBI.html">introductory tutorial</a>.</p>
<p>The interface is designed to be simple and consistent, making it easy to switch between different DBMSes. Packages built on top of DBI, such as <a href="https://dbplyr.tidyverse.org/">dbplyr</a> or <a href="https://docs.ropensci.org/arkdb/">arkdb</a>, provide additional functionality and convenience. New backends can be implemented by following the <a href="https://dbi.r-dbi.org/articles/spec.html">DBI specification</a>, which comes with a comprehensive test suite in the <a href="https://dbitest.r-dbi.org/">DBItest</a> package. The <a href="https://rkazam.r-dbi.org/">RKazam</a> template makes it easy to get started. (Spoiler alert: We know because a new backend has been added recently. Read on!)</p>
<p>This blog post series consists of three parts. In this first part, we summarize recent developments in DBI and related packages, including a glimpse on the new <a href="https://adbi.r-dbi.org/">adbi</a> package. The <a href="https://r-dbi.org/blog/dbi-4-2/">second part</a> reviews the time it takes to respond to issues and pull requests. In the <a href="https://r-dbi.org/blog/dbi-4-3/">third part</a>, we will do a deeper dive into the new adbi and adbcdrivermanager packages, which use the Arrow data exchange format and offer a more sustainable approach to database connectivity.</p>
<p>Similar articles are available from previous years, reporting on earlier states of the DBI ecosystem:</p>
<ul>
<li><a href="https://www.r-dbi.org/blog/dbi-3-3.html">4/4: December 2021</a></li>
<li><a href="https://www.r-dbi.org/blog/dbi-3-3.html">3/4: January 2021</a></li>
<li><a href="https://www.r-dbi.org/blog/dbi-3-2.html">2/4: December 2019</a></li>
<li><a href="https://www.r-dbi.org/blog/dbi-3-1.html">1/4: December 2018</a></li>
</ul>
</section>
<section id="overall" class="level2">
<h2 class="anchored" data-anchor-id="overall">Overall</h2>
<section id="improve-cicd-infrastructure" class="level3">
<h3 class="anchored" data-anchor-id="improve-cicd-infrastructure">Improve CI/CD infrastructure</h3>
<p>Packages run their own checks and the checks for related components. For example, DBI now runs DBItest with RSQLite, and DBItest runs checks for all backends, including odbc. This ensures interoperability between CRAN and development versions of the packages and helps to catch issues early.</p>
<p>Several components simplify the day-to-day work:</p>
<ul>
<li><p><a href="https://www.aviator.co/">Aviator</a> helps ensuring always ‚Äúgreen‚Äù builds on the main branch.</p>
<p>It is a ‚Äúclick-and-forget‚Äù solution that allows queueing a pull request so that it is automatically merged when all checks pass. I‚Äôm using this for all my packages now, and it has saved me a lot of time. I also tried the native GitHub merge queue, but it seems to require protecting the main branch, which is required for fledge. üëá</p></li>
<li><p><a href="https://fledge.cynkra.com/">fledge</a> helps automating the release process.</p>
<p>This package generates a changelog from PR titles. In my setup, it is run daily and automatically updates <code>NEWS.md</code>. Before release to CRAN, the changelog is manually converted to release notes. Once a package is on CRAN, a GitHub release is created with these release notes.</p></li>
<li><p>All packages use a similar but not identical setup for CI/CD.</p>
<p>For example, the DBMS installed differs between backends. To manage this and also allow continuous improvement of the CI/CD process, I‚Äôm using <a href="https://github.com/krlmlr/actions-sync">bidirectional synchronization</a> to and from a central repository. This allows me to make changes in one of the repositories and have them applied to all other repositories. Among other things, the improved CI/CD workflows automatically open pull requests for changes to autogenerated files such as <code>.Rd</code> files or the results of snapshot tests.</p></li>
</ul>
</section>
<section id="improve-testing-infrastructure" class="level3">
<h3 class="anchored" data-anchor-id="improve-testing-infrastructure">Improve testing infrastructure</h3>
<p>Testing DBI and associated packages often requires a database server. While it is easy enough to install MariaDB and PostgreSQL to run locally, running Oracle and SQL Server on macOS requires Docker. If <em>some</em> databases require Docker, why not run <em>all</em> databases in Docker? This gives the additional advantage of being able to install different versions of the same database server side by side, and to easily recreate a fresh test environment.</p>
<p>The <a href="https://github.com/r-dbi/docker">docker</a> repository aims at providing a consistent and easy-to-use setup for all databases and all packages. It uses Docker Compose to turn otherwise complex command line invocations into a single <code>docker-compose</code> command. The goals are:</p>
<ul>
<li><p>Have a single robust command to create a server and a test connection, testable with CI/CD.</p></li>
<li><p>Offer an easy way to run tests or scripts against a particular database server, using a development version of a backend package.</p></li>
<li><p>Support testing all useful combinations of DBI backend and database server.</p></li>
<li><p>Make it easy to add new database versions, new databases, and new backends.</p></li>
</ul>
<p>The repository is still in its early stages, but it already supports MariaDB, MySQL, PostgreSQL, SQLite, SQL Server, and Oracle. Feedback and contributions are welcome.</p>
</section>
<section id="documentation-improvements" class="level3">
<h3 class="anchored" data-anchor-id="documentation-improvements">Documentation improvements</h3>
<p>Various documentation improvements have been made:</p>
<ul>
<li><p>The DBI specification is now version-controlled as Markdown files. This allows for more control and a simpler build process. Previously has been assembled at package build time from various sources.</p></li>
<li><p>The command execution and data retrieval flow has been clarified in the documentation. This has been a common source of confusion for new users.</p></li>
<li><p>All packages now use the new pkgdown documentation template at <a href="https://github.com/r-dbi/dbitemplate" class="uri">https://github.com/r-dbi/dbitemplate</a>, and the website at <a href="https://r-dbi.org" class="uri">https://r-dbi.org</a> is now built using Quarto. Thanks to Ma√´lle Salmon (<a href="https://github.com/maelle">@maelle</a>)!</p></li>
</ul>
</section>
<section id="move-to-cpp11" class="level3">
<h3 class="anchored" data-anchor-id="move-to-cpp11">Move to cpp11</h3>
<p>The RSQLite, RPostgres, and RMariaDB packages are now using the <a href="https://cpp11.r-lib.org/">cpp11</a> package for the glue between R and C++. This header-only package provides a modern C++11 interface to R, the header files can be vendored into the backend packages if needed. Other highlights include the use ‚ÄúUTF-8 everywhere‚Äù paradigm, improved safety of C API calls, and a faster implementation of protection.</p>
</section>
<section id="avoid-tidying-of-duplicate-column-names" class="level3">
<h3 class="anchored" data-anchor-id="avoid-tidying-of-duplicate-column-names">Avoid tidying of duplicate column names</h3>
<p>The RSQLite, RPostgres, and RMariaDB packages no longer change duplicate column names. The behavior in the presence of duplicate column names was not specified in the DBI specification, but imposing a tidying step seems out of scope for a database interface. It is now up to the user to handle duplicate column names, for example by using <code>janitor::clean_names()</code>.</p>
</section>
</section>
<section id="adbi-new-release-in-collaboration-with-voltron-data" class="level2">
<h2 class="anchored" data-anchor-id="adbi-new-release-in-collaboration-with-voltron-data">adbi: new release in collaboration with Voltron Data</h2>
<p>The new adbi package bridges ADBC drivers and DBI. Examples include:</p>
<ul>
<li><a href="https://arrow.apache.org/adbc/current/r/adbcsqlite/">adbcsqlite</a>, on CRAN</li>
<li><a href="https://arrow.apache.org/adbc/current/r/adbcpostgresql/">adbcpostgresql</a>, on CRAN</li>
<li><a href="https://github.com/apache/arrow-adbc/tree/main/r/adbcsnowflake">adbcsnowflake</a> for <a href="https://www.snowflake.com/">Snowflake</a></li>
<li><a href="https://github.com/apache/arrow-adbc/tree/main/r/adbcflightsql">adbcflightsql</a> for <a href="https://arrow.apache.org/docs/format/FlightSql.html">FlightSQL</a></li>
<li><a href="https://duckdb.org/docs/api/r">duckdb</a>, which implements an ADBC driver in addition to the DBI backend</li>
</ul>
<p><a href="https://arrow.apache.org/adbc/">ADBC</a> (Arrow database connectivity) is</p>
<blockquote class="blockquote">
<p>an API standard for database access libraries that uses Arrow for result sets and query parameters.</p>
</blockquote>
<p>The adbi package allows existing code that uses DBI to seamlessly interact with the new ADBC drivers, but this will not improve performance. To facilitate the switch to using Arrow as a data interchange format, adbi supports access via data frames and Arrow side by side, on the same connection object, using the new generics defined by DBI. For example, with <code>dbGetQueryArrow()</code>, the result set is passed to R as an Arrow stream, bypassing the expensive conversion to data frames. More on that below.</p>
<p>Development of the adbi package has been made easy with the RKazam package, which is a template for creating DBI backends, and the DBItest package, which provides a battery of tests that all ‚Äúpass‚Äù with the package generated from the template and help guide the development process. Thanks to Nicolas Bennett (<a href="https://github.com/nbenn">@nbenn</a>) for the implementation and the wonderful collaboration, and to <a href="https://voltrondata.com/">Voltron Data</a> for supporting this effort.</p>
</section>
<section id="dbi" class="level2">
<h2 class="anchored" data-anchor-id="dbi">DBI</h2>
<p>This package has seen a minor update to 1.2.2. See the <a href="https://dbi.r-dbi.org/news/index.html">change log</a> for the full details.</p>
<section id="integration-with-arrow" class="level3">
<h3 class="anchored" data-anchor-id="integration-with-arrow">Integration with Arrow</h3>
<p>DBI backens can now optionally support Arrow arrays and streams as the primary data exchange format. This is accessed through the new generics <code>dbSendQueryArrow()</code>, <code>dbFetchArrow()</code>, <code>dbFetchArrowChunk()</code>, <code>dbGetQueryArrow()</code>, <code>dbReadTableArrow()</code>, <code>dbWriteTableArrow()</code>, <code>dbCreateTableArrow()</code>, <code>dbAppendTableArrow()</code>, and <code>dbBindArrow()</code>. See the new <a href="https://dbi.r-dbi.org/articles/DBI-arrow.html">vignette on Arrow support in DBI</a> for details.</p>
<p>A default implementation is provided in the DBI package, this means that the new interface can be used with any DBI backend without changes to the backend package. Performance and interoperability gains can be achieved by directly implementing the Arrow interface in the backend package, as the new adbi package does.</p>
<p>The following example illustrates two options to connect with a PostgreSQL database. In both scenarios, the libpq library is used to communicate with the database server. The RPostgres package links to libpq, the PostgreSQL client library, and uses this API directly to retrieve and ingest data from R via the DBI interface. The adbcpostgresql package also links to libpq but exposes ADBC, which is brought to R with the adbcdrivermanager package. On top of that, the adbi package interacts with arbitrary ADBC drivers (including adbcpostgresql) and exposes the functionality through DBI. The R user has the choice to access the data via data frames or via Arrow. When using adbi and the new <code>dbGetQueryArrow()</code>, the implementation will never convert the data to R data frames. This allows, e.g., directly saving the result to a Parquet file, or further processing it with Arrow. In all other cases, a conversion to R data frames will occur.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://r-dbi.org/blog/dbi-4-1/adbi.png" class="img-fluid figure-img" alt="Space divided into two areas, R data frames at the left, Arrow at the right. Two concurrent data flows from libpq to DBI are shown: one via RPostgres through R data frames, one via adbcpostgresql and adbi through Arrow. The two flows merge at the DBI layer. From DBI, consumers can use dbGetQuery() to get data frames, or dbGetQueryArrow() to get Arrow streams."></p>
<figcaption>Data flow from libpq to consumers</figcaption>
</figure>
</div>
<p>While the Arrow path seems to involve more components, it is the most efficient way to interact with the database because the data is threaded through from adbcpostgresql to R without any conversion or even copying. The only conversion occurs in adbcpostgresql, when the data returned by libpq is converted to Arrow format.</p>
<p>With FlightSQL, the data will be passed in the Arrow format end to end, this requires support in the database <em>server</em>. This is a promising development. By using adbi or adbcdrivermanager, R users can seamlessly transition to FlightSQL when it becomes available in their database.</p>
<p>Thanks to <a href="https://voltrondata.com/">Voltron Data</a> for supporting this effort!</p>
</section>
<section id="object-identifiers" class="level3">
<h3 class="anchored" data-anchor-id="object-identifiers">Object identifiers</h3>
<p>The <code>Id()</code> class has been changed to unnamed components, as the explicit naming of the components (‚Äúdatabase‚Äù, ‚Äúschema‚Äù, ‚Äútable‚Äù) was not used in practice. This also affects the <code>dbQuoteIdentifier()</code>, <code>dbUnquoteIdentifier()</code>, and <code>dbListObjects()</code> generics, which now accept and return unnamed <code>Id()</code> objects.</p>
</section>
</section>
<section id="dbitest" class="level2">
<h2 class="anchored" data-anchor-id="dbitest">DBItest</h2>
<p>The DBItest package has seen a minor update to 1.8.1. See the <a href="https://dbitest.r-dbi.org/news/index.html">change log</a> for details.</p>
<section id="code-generation" class="level3">
<h3 class="anchored" data-anchor-id="code-generation">Code generation</h3>
<p><a href="https://mtlynch.io/good-developers-bad-tests/">Why good developers write bad unit tests</a>? In a nutshell, production code should avoid repetition and hard-coded constant, while testing code should be as explicit and as easy to understand and execute as possible.</p>
<p>The DBItest package is home to both the specification of the DBI package and a test suite for DBI backends. As such, good software engineering practices are actually useful here and have helped cover many corner cases in the DBI backends. Running the tests in DBItest is easy, but in the case of a failure, the error messages are not always helpful. Backend developers typically have to read the test code to understand what went wrong. And if the actual test code hides between layers of abstraction, this can be a daunting task.</p>
<p>Code generation has proved to be a powerful tool to peel off abstraction layers, for instance in the <a href="https://duckplyr.tidyverse.org/">duckplyr</a> project. In R, code is data, and the language and the associated packages are very well suited for this task. The long-term goal is to turn DBItest into a <em>code generator</em> rather than a <em>test executor</em>: the test code will be generated from a specification directly into the backend package and executed there. In the case of a failure, the error message will point to the generated code and to the relevant part of the specification. Failing tests can be executed trivially, very much like failures in regular tests. The expected behavior becomes apparent from the generated code, leading to a better understanding of the failure and a more efficient debugging process.</p>
<p>A first step has been taken in this direction, the tests for the command execution and data retrieval flows via <code>dbBind()</code> have been refactored to generate inline code in the DBItest package. The process towards full code generation requires similar steps in a few other places to avoid hard-to-understand generated code, which would be even worse than the current situation.</p>
</section>
<section id="decoupling-from-backends" class="level3">
<h3 class="anchored" data-anchor-id="decoupling-from-backends">Decoupling from backends</h3>
<p>As DBItest continues to evolve, and more backends are using it, the ability to add or update checks without affecting all downstream packages becomes crucial. Each new or modified test will require the backend package to opt in by updating the DBItest version in their <code>tweaks()</code> call. Once the code generation is in place, this will become less of an issue, but for now this helps with the ongoing development.</p>
</section>
<section id="other-improvements" class="level3">
<h3 class="anchored" data-anchor-id="other-improvements">Other improvements</h3>
<p>The new Arrow generics are now tested in DBItest, and the tests have been integrated into the CI/CD pipeline.</p>
<p>A new tweak <code>allow_na_rows_affected</code> has been added to support <code>NA</code> values returned from <code>dbGetRowsAffected()</code> and passed as the <code>n</code> argument to <code>dbFetch()</code>.</p>
</section>
</section>
<section id="backend-packages-rsqlite-rmariadb-rpostgres" class="level2">
<h2 class="anchored" data-anchor-id="backend-packages-rsqlite-rmariadb-rpostgres">Backend packages: RSQLite, RMariaDB, RPostgres</h2>
<ul>
<li><p>RSQLite has seen a minor update, the current version is 2.3.6. See the <a href="https://rsqlite.r-dbi.org/news/index.html">change log</a> for details.</p>
<p>The automatic update of the bundled SQLite library has enabled continuous and timely updates of the RSQLite package on CRAN. The latest version of SQLite is 3.45.2, and the RSQLite package is now bundling it. For this reason, the known authors of SQLite have been added to the <code>DESCRIPTION</code> file. This process allows quicker updates of SQLite than if installing from <a href="https://repology.org/project/sqlite/versions">OS package repositories</a>, and precise control of the underlying SQLite version used in a project.</p>
<p>Other minor changes include support for the icpc compiler, and a new <code>sqliteIsTransacting()</code> function that returns if a transaction is active on the current connection.</p></li>
<li><p>RMariaDB has also seen a minor update. The current version is 1.3.1. See the <a href="https://rmariadb.r-dbi.org/news/index.html">change log</a> for details.</p>
<p>MariaDB is a fork of MySQL, and both packages continue to evolve. There are small but important differences between the two DBMSs, and the RMariaDB package is now more explicit about the differences. Connections now inherit from <code>"MySQLConnection"</code> if a MySQL server is detected (server version &lt; 10.0 and server description does not contain <code>"MariaDB"</code>). The new <code>mysql</code> argument to <code>dbConnect()</code> allows overriding the autodetection. This means that code can behave differently depending on the underlying database server.</p>
<p>Similarly to RPostgres and odbc, RMariaDB now supports <code>dbSendStatement(immediate = TRUE)</code> and <code>dbExecute(immediate = TRUE)</code>. This sends the query to the server without preparing it, which is mandatory for some queries. For this to work, the connection needs to be opened with the <code>CLIENT_MULTI_STATEMENTS</code> flag.</p>
<p>Other changes include:</p>
<ul>
<li><p>Support for <code>TIME</code> columns with subsecond precision.</p></li>
<li><p>The use of strings as default for JSON and all unknown column types.</p></li>
</ul></li>
<li><p>RPostgres has seen a minor update, mostly focusing on maintenance. The current version is 1.4.6. See the <a href="https://rpostgres.r-dbi.org/news/index.html">change log</a> for details.</p></li>
</ul>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Quite a few things have happened in the DBI ecosystem since the last blog post. Try out the new package versions, let us know if they work for you, and report any problems you encounter in the respective issue trackers on GitHub. Happy querying!</p>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>Thanks to Ma√´lle Salmon (<a href="https://github.com/maelle">@maelle</a>) and Nicolas Bennett (<a href="https://github.com/nbenn">@nbenn</a>) for their help with the blog post, and to the numerous contributors to the packages in the ‚ÄúMaintaining DBI‚Äù project in 2022 and 2023:</p>
<ul>
<li><p>DBI: <a href="https://github.com/apalacio9502">@apalacio9502</a>, <a href="https://github.com/asadow">@asadow</a>, <a href="https://github.com/bcorwin">@bcorwin</a>, <a href="https://github.com/capitantyler">@capitantyler</a>, <a href="https://github.com/chrisdane">@chrisdane</a>, <a href="https://github.com/eauleaf">@eauleaf</a>, <a href="https://github.com/eitsupi">@eitsupi</a>, <a href="https://github.com/eriksquires">@eriksquires</a>, <a href="https://github.com/fnavarro94">@fnavarro94</a>, <a href="https://github.com/GitHunter0">@GitHunter0</a>, <a href="https://github.com/hadley">@hadley</a>, <a href="https://github.com/hannes101">@hannes101</a>, <a href="https://github.com/Jay123ub">@Jay123ub</a>, <a href="https://github.com/jd4ds">@jd4ds</a>, <a href="https://github.com/kelseyroberts">@kelseyroberts</a>, <a href="https://github.com/latot">@latot</a>, <a href="https://github.com/maelle">@maelle</a>, <a href="https://github.com/matthiasgomolka">@matthiasgomolka</a>, <a href="https://github.com/mgirlich">@mgirlich</a>, <a href="https://github.com/mmuurr">@mmuurr</a>, <a href="https://github.com/nbenn">@nbenn</a>, <a href="https://github.com/philibe">@philibe</a>, <a href="https://github.com/pnacht">@pnacht</a>, <a href="https://github.com/r2evans">@r2evans</a>, <a href="https://github.com/renkun-ken">@renkun-ken</a>, <a href="https://github.com/salim-b">@salim-b</a>, <a href="https://github.com/scottfrechette">@scottfrechette</a>, and <a href="https://github.com/tzakharko">@tzakharko</a>.</p></li>
<li><p>DBItest: <a href="https://github.com/barracuda156">@barracuda156</a>, <a href="https://github.com/detule">@detule</a>, <a href="https://github.com/dpprdan">@dpprdan</a>, <a href="https://github.com/hadley">@hadley</a>, <a href="https://github.com/maelle">@maelle</a>, <a href="https://github.com/MichaelChirico">@MichaelChirico</a>, <a href="https://github.com/nbenn">@nbenn</a>, <a href="https://github.com/psychelzh">@psychelzh</a>, and <a href="https://github.com/TSchiefer">@TSchiefer</a>.</p></li>
<li><p>RSQLite: <a href="https://github.com/Antonov548">@Antonov548</a>, <a href="https://github.com/arnaud-feldmann">@arnaud-feldmann</a>, <a href="https://github.com/bpvgoncalves">@bpvgoncalves</a>, <a href="https://github.com/chodarq">@chodarq</a>, <a href="https://github.com/Daniel-Zhou-93">@Daniel-Zhou-93</a>, <a href="https://github.com/DavorJ">@DavorJ</a>, <a href="https://github.com/eriksquires">@eriksquires</a>, <a href="https://github.com/gaospecial">@gaospecial</a>, <a href="https://github.com/gavril0">@gavril0</a>, <a href="https://github.com/github-actions%5Bbot%5D">@github-actions[bot]</a>, <a href="https://github.com/hadley">@hadley</a>, <a href="https://github.com/IdoBar">@IdoBar</a>, <a href="https://github.com/JeremyPasco">@JeremyPasco</a>, <a href="https://github.com/joethorley">@joethorley</a>, <a href="https://github.com/kjellpk">@kjellpk</a>, <a href="https://github.com/kmishra9">@kmishra9</a>, <a href="https://github.com/krlmlr">@krlmlr</a>, <a href="https://github.com/lolow">@lolow</a>, <a href="https://github.com/maelle">@maelle</a>, <a href="https://github.com/MichaelChirico">@MichaelChirico</a>, <a href="https://github.com/nathaneastwood">@nathaneastwood</a>, <a href="https://github.com/nunotexbsd">@nunotexbsd</a>, <a href="https://github.com/RoganGrant">@RoganGrant</a>, <a href="https://github.com/SarenT">@SarenT</a>, <a href="https://github.com/stephenashton-dhsc">@stephenashton-dhsc</a>, <a href="https://github.com/wibeasley">@wibeasley</a>, and <a href="https://github.com/xmart">@xmart</a>.</p></li>
<li><p>RPostgres: <a href="https://github.com/abalter">@abalter</a>, <a href="https://github.com/ablack3">@ablack3</a>, <a href="https://github.com/agilly">@agilly</a>, <a href="https://github.com/aliarsalankazmi">@aliarsalankazmi</a>, <a href="https://github.com/ankane">@ankane</a>, <a href="https://github.com/Antonov548">@Antonov548</a>, <a href="https://github.com/bhogan-mitre">@bhogan-mitre</a>, <a href="https://github.com/castagninojose">@castagninojose</a>, <a href="https://github.com/DavisVaughan">@DavisVaughan</a>, <a href="https://github.com/dmkaplan2000">@dmkaplan2000</a>, <a href="https://github.com/dpprdan">@dpprdan</a>, <a href="https://github.com/geneorama">@geneorama</a>, <a href="https://github.com/gui-salome">@gui-salome</a>, <a href="https://github.com/ilarischeinin">@ilarischeinin</a>, <a href="https://github.com/jeroen">@jeroen</a>, <a href="https://github.com/karawoo">@karawoo</a>, <a href="https://github.com/kevinpalm">@kevinpalm</a>, <a href="https://github.com/kmishra9">@kmishra9</a>, <a href="https://github.com/maelle">@maelle</a>, <a href="https://github.com/majazaloznik">@majazaloznik</a>, <a href="https://github.com/meztez">@meztez</a>, <a href="https://github.com/mgirlich">@mgirlich</a>, <a href="https://github.com/mmuurr">@mmuurr</a>, <a href="https://github.com/nbenn">@nbenn</a>, <a href="https://github.com/pachadotdev">@pachadotdev</a>, <a href="https://github.com/pedrobtz">@pedrobtz</a>, <a href="https://github.com/samterfa">@samterfa</a>, <a href="https://github.com/sbamin">@sbamin</a>, <a href="https://github.com/stefan-m-lenz">@stefan-m-lenz</a>, and <a href="https://github.com/veer0318">@veer0318</a>.</p></li>
<li><p>RMariaDB: <a href="https://github.com/Antonov548">@Antonov548</a>, <a href="https://github.com/arecibo">@arecibo</a>, <a href="https://github.com/bergernetch">@bergernetch</a>, <a href="https://github.com/BillWeld">@BillWeld</a>, <a href="https://github.com/cboettig">@cboettig</a>, <a href="https://github.com/d-hansen">@d-hansen</a>, <a href="https://github.com/EllyJung">@EllyJung</a>, <a href="https://github.com/frabau1">@frabau1</a>, <a href="https://github.com/ghost">@ghost</a>, <a href="https://github.com/GitHunter0">@GitHunter0</a>, <a href="https://github.com/GraphZal">@GraphZal</a>, <a href="https://github.com/GundryLab">@GundryLab</a>, <a href="https://github.com/hpages">@hpages</a>, <a href="https://github.com/jay-sf">@jay-sf</a>, <a href="https://github.com/jd4ds">@jd4ds</a>, <a href="https://github.com/jeroen">@jeroen</a>, <a href="https://github.com/KevinYie">@KevinYie</a>, <a href="https://github.com/kwakuduahc1">@kwakuduahc1</a>, <a href="https://github.com/lbui30">@lbui30</a>, <a href="https://github.com/LeeMendelowitz">@LeeMendelowitz</a>, <a href="https://github.com/LukeBla">@LukeBla</a>, <a href="https://github.com/maelle">@maelle</a>, <a href="https://github.com/mbarneytu">@mbarneytu</a>, <a href="https://github.com/mgirlich">@mgirlich</a>, <a href="https://github.com/MySocialPulse">@MySocialPulse</a>, <a href="https://github.com/NoProblemJack">@NoProblemJack</a>, <a href="https://github.com/pekkarr">@pekkarr</a>, <a href="https://github.com/psychelzh">@psychelzh</a>, <a href="https://github.com/pythiantech">@pythiantech</a>, <a href="https://github.com/renkun-ken">@renkun-ken</a>, <a href="https://github.com/rorynolan">@rorynolan</a>, <a href="https://github.com/ryan-hdez">@ryan-hdez</a>, <a href="https://github.com/SwissMontainsBear">@SwissMontainsBear</a>, <a href="https://github.com/uhkeller">@uhkeller</a>, and <a href="https://github.com/vanhry">@vanhry</a>.</p></li>
</ul>


</section>

 ]]></description>
  <guid>https://r-dbi.org/blog/dbi-4-1/</guid>
  <pubDate>Tue, 02 Apr 2024 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Maintaining DBI, 4/4</title>
  <dc:creator>Kirill M√ºller</dc:creator>
  <link>https://r-dbi.org/blog/dbi-3-4/</link>
  <description><![CDATA[ 




<!-- how do you want to pluralize abbreviations? DBMSes, DBMS's DBMSs? -->
<section id="what-is-dbi" class="level2">
<h2 class="anchored" data-anchor-id="what-is-dbi">What is DBI?</h2>
<p>The {DBI} package (<strong>d</strong>ata<strong>b</strong>ase <strong>i</strong>nterface) provides an abstraction for communication between R and database management systems (DBMSes) by specifying a common application programming interface (API). Actual connectivity to DBMSes is established via database specific <a href="https://github.com/r-dbi/backends#readme">backend packages</a>, implementing this interface. Examples for such backends include <a href="https://rpostgres.r-dbi.org/">RPostgres</a>, <a href="https://rmariadb.r-dbi.org/">RMariaDB</a>, and <a href="https://rsqlite.r-dbi.org/">RSQLite</a>. For users that are new to DBI, the <a href="https://dbi.r-dbi.org/articles/DBI.html">introductory tutorial</a> provides a good entry point for getting acquainted with some key concepts.</p>
<p>This blog post summarizes recent developments in {DBI} and related packages and concludes with an outlook on potential future directions. Similar articles are available from previous years, reporting on earlier states of the {DBI} ecosystem:</p>
<ul>
<li><a href="https://www.r-dbi.org/blog/dbi-3-3.html">3/4: January 2021</a></li>
<li><a href="https://www.r-dbi.org/blog/dbi-3-2.html">2/4: December 2019</a></li>
<li><a href="https://www.r-dbi.org/blog/dbi-3-1.html">1/4: December 2018</a></li>
</ul>
</section>
<section id="recent-developments" class="level2">
<h2 class="anchored" data-anchor-id="recent-developments">Recent developments</h2>
<p>Several packages associated with DBI have been updated since <a href="https://www.r-dbi.org/blog/dbi-3-3.html">early 2021</a>:</p>
<ul>
<li>DBI 1.1.1 -&gt; 1.1.2 (<a href="https://dbi.r-dbi.org/news/">NEWS</a>)</li>
<li>RMariaDB 1.1.0 -&gt; 1.2.1 (<a href="https://rmariadb.r-dbi.org/news/">NEWS</a>)</li>
<li>RPostgres 1.3.1 -&gt; 1.4.3 (<a href="https://rpostgres.r-dbi.org/news/">NEWS</a>)</li>
<li>RSQLite 2.2.2 -&gt; 2.2.9 (<a href="https://rsqlite.r-dbi.org/news/">NEWS</a>)</li>
<li>DBItest 1.7.0 -&gt; 1.7.2 (<a href="https://dbitest.r-dbi.org/news/">NEWS</a>)</li>
</ul>
<p>And the following sections elaborate on some of the noteworthy changes and improvements contained in these updates, both user-visible and internal.</p>
<section id="clickable-method-documentation" class="level3">
<h3 class="anchored" data-anchor-id="clickable-method-documentation">Clickable method documentation</h3>
<p>The DBI method reference on <a href="https://dbi.r-dbi.org/reference/" class="uri">https://dbi.r-dbi.org/reference/</a> has been updated to include clickable links to known DBI backends. This makes documentation specific to certain backends more accessible, as optional function arguments used by some backend implementations are only documented by the respective packages.</p>
</section>
<section id="full-support-for-aws-redshift" class="level3">
<h3 class="anchored" data-anchor-id="full-support-for-aws-redshift">Full support for AWS Redshift</h3>
<p>Redshift support has been greatly improved by Adam Fory≈õ as part of the RPostgres package and both databases now pass all applicable tests offered by DBItest. The BLOB data type is currently not supported by Redshift and consequently, related tests are skipped. For connecting to a Redshift cluster, the RPostgres package exports <code>Redshift()</code> (to be used over <code>Postgres()</code>).</p>
</section>
<section id="faster-table-imports" class="level3">
<h3 class="anchored" data-anchor-id="faster-table-imports">Faster table imports</h3>
<p>Previous versions of {RMariaDB} and {RPostgres} relied <code>dbBind()</code> for writing tables, using a prepared <code>INSERT INTO ... VALUES (...)</code> statement with placeholders. Contrary to the expectation, this was very inefficient, because each row requires a communication roundtrip to the server. To improve the situation, {RMariaDB} now uses <code>LOAD DATA LOCAL INFILE</code> to load data from a temporary CSV file. Recent MySQL server versions disable this capability by default, and therefore it is also disabled by default in {RMariaDB}. If your server supports this, enable fast loading by passing <code>load_data_local_infile = TRUE</code> to <code>dbConnect()</code>. For {RPostgres}, <code>dbAppendTable()</code> has been updated to use the same optimization as <code>dbWriteTable()</code> when writing data.</p>
</section>
<section id="windows-compatibility" class="level3">
<h3 class="anchored" data-anchor-id="windows-compatibility">Windows compatibility</h3>
<p>{RMariaDB} can now use the <code>caching_sha2_password</code> plugin on Windows which was permanently disabled on previous versions. This is important for connecting to recent versions of MySQL which require this plugin.</p>
</section>
<section id="extended-data-types-for-sqlite" class="level3">
<h3 class="anchored" data-anchor-id="extended-data-types-for-sqlite">Extended data types for SQLite</h3>
<p>Thanks to Eric Anderson, {RSQLite} now returns typed data for columns declared with <code>DATE</code>, <code>TIME</code> and <code>TIMESTAMP</code> data types. To enable this feature, <code>extended_types = TRUE</code> has to be passed in <code>dbConnect()</code>.</p>
</section>
<section id="interrupt-handling" class="level3">
<h3 class="anchored" data-anchor-id="interrupt-handling">Interrupt handling</h3>
<p>The <code>check_interrupts = TRUE</code> argument to <code>dbConnect()</code> in {RPostgres} now correctly cancels the query and returns to the user as soon as an interrupt is signalled (by pressing Ctrl+C or Escape in RStudio). Thanks to Mateusz ≈ª√≥≈Çtak for tests and discussion.</p>
</section>
<section id="automation" class="level3">
<h3 class="anchored" data-anchor-id="automation">Automation</h3>
<p>{RMariaDB} is tested against all combinations of major MariaDB and MySQL client/server releases, while {RPostgres} is tested against all versions of PostgreSQL ‚â• 10 using GitHub Actions. This guarantees compatibility with a broader range of database instances for both backends and for future updates to the corresponding packages. All tests are run daily, thereby ensuring that upstream updates remain compatible with backend implementations. The database servers are installed on GitHub Actions using dedicated actions for installing <a href="https://github.com/ankane/setup-mariadb/">MariaDB</a>, <a href="https://github.com/ankane/setup-mysql">MySQL</a> and <a href="https://github.com/ankane/setup-postgres">Postgres</a>, maintained by Andrew Kane.</p>
<p>Thanks to the automated monitoring of SQLite3 releases, the vendored code can be updated continuously with minimal delay over upstream releases. {RSQLite} now uses SQLite3 3.37.0 and became available from CRAN only 10 days after the upstream release.</p>
</section>
<section id="simpler-upgrade-path-for-dbitest" class="level3">
<h3 class="anchored" data-anchor-id="simpler-upgrade-path-for-dbitest">Simpler upgrade path for DBItest</h3>
<p>By making it possible for backends to specify the supported version of {DBItest}, using <code>tweaks(dbitest_version = "x.y.z")</code>, it is now simpler to update {DBItest} on CRAN. Newly added tests in {DBItest} are skipped if the declared version is too low. Skipped tests are reported in the test results and can be fixed independently of the {DBItest} releases.</p>
</section>
<section id="inlined-boost-headers" class="level3">
<h3 class="anchored" data-anchor-id="inlined-boost-headers">Inlined Boost headers</h3>
<p>The {BH} package is a C++ header-only package containing in excess of 10,000 individual files and installation has proven challenging for some systems, such as Amazon‚Äôs Elastic File System. By vendoring only the required files into {RSQLite}, {RMariaDB} and {RPostgres}, it is no longer necessary to install {BH} to use these packages, and therefore the total number of files required to build these packages is greatly reduced. Thanks to RStudio for supporting this change.</p>
</section>
<section id="reorganized-structure-of-the-r-code" class="level3">
<h3 class="anchored" data-anchor-id="reorganized-structure-of-the-r-code">Reorganized structure of the R code</h3>
<p>{DBI} uses S4 classes and generic functions to specify the interface to be implemented by backends, using database specific subclasses. Class specific generic implementations are consequently declared with <code>setMethod()</code>, using the following convention:</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">setMethod</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"foo"</span>, <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"myclass"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"character"</span>), <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">function</span>(x, char_arg, ...) {</span>
<span id="cb1-2">  ...</span>
<span id="cb1-3">})</span></code></pre></div>
<p>Instead of passing an anonymous function as <code>definition</code> argument to <code>setMethod()</code>, this has been changed to a semantic equivalent which is more explicit:</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1">foo_myclass_character <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">function</span>(x, char_arg, ...) {</span>
<span id="cb2-2">  ...</span>
<span id="cb2-3">}</span>
<span id="cb2-4"></span>
<span id="cb2-5"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">setMethod</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"foo"</span>, <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"myclass"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"character"</span>), foo_myclass_mycharacter)</span></code></pre></div>
<p>Reasons for this transformation were to make the respective implementations more accessible, as function definitions now can be displayed more easily via <code>mypkg:::foo_myclass_character</code>, and to generally make the code-base easier to read and navigate. In similar spirit, each such generic implementation is now defined in its own file with file names constructed as <code>foo_myclass_mycharacter.R</code>. This makes it immediately clear, exactly which methods are implemented by a package, simply from the list of associated files. Code transformation was carried out in semi-automated fashion, with the help of a <a href="https://github.com/pre-processing-r/rpp/blob/main/script/un-s4.R">script</a> that uses infrastructure from the ‚ÄúPre-processing R code‚Äù project.</p>
</section>
</section>
<section id="future-work" class="level2">
<h2 class="anchored" data-anchor-id="future-work">Future work</h2>
<p>The {DBI} package provides a low-level interface for database connectivity with a <a href="https://www.r-dbi.org/blog/dbi-3-3.html">narrow scope</a>. Data query and manipulation tasks that are not in-scope for {DBI} are currently left to auxiliary packages, including <a href="https://dbplyr.tidyverse.org/">dbplyr</a>, <a href="https://cynkra.github.io/dm/">dm</a>, <a href="https://github.com/ankane/dbx">dbx</a> and <a href="https://winvector.github.io/rquery/">rquery</a>. {DBI} uses S4, one of several systems for object-oriented programming in R. While S4 offers several advantages over its predecessor S3, including increased strictness and multiple dispatch, it also is more rigid compared to S3. <!-- I don't see how this is specific to S4, but then again, I haven't really used S4 myself, so I'm no expert; it might still be worthwhile to elaborate a bit here --> <!-- also, what is the intention of discussing S4 here? is it to justify a move away from S4? if so I feel a need for fleshing out this argument more --> Consequently, once the definition of a generic is published, it is difficult to make changes without breaking downstream dependencies.</p>
<p>The first release of {DBI} dates back roughly 20 years and since, the package has been widely adopted by others, both for accessing databases or providing <a href="https://github.com/r-dbi/backends#readme">backends</a> to DBMSes. Its success, combined with the rigidity imposed by S4, has made it difficult to extend the interface beyond what is currently offered. When considering new additions, there is pressure to get it right in the first attempt, thereby holding back less essential improvements.</p>
<p>The DBI specification in the {DBItest} package aims to standardize the feature set of {DBI}-compliant backends, and to provide a test suite against which conformity of an implementation can be verified. Due to differences in design of individual DBMSes, not all features of the DBI specification and therefore not all tests provided by {DBItest} are supported by all backend packages. Using a newly introduced mechanism, backends can declare, by means of <em>tweaks</em>, which tests to run in what way. This addresses some of the problems associated with implementing a test suite that can be re-used for several backends. General-purpose clients however, can only make guesses as to the exact feature set supported by a given backend or connection. There currently is no formal way to declare certain capabilities as missing (or available).</p>
<p>Based on these observations, for extending DBI, it may be worthwhile to address the following two issues:</p>
<ol type="1">
<li>Formal declaration of capabilities.</li>
<li>Decoupling the user from the backend interface.</li>
</ol>
<p>The new <a href="https://github.com/r-dbi/dbi3">dbi3 repository</a> contains a collection of issues, some of which will be easier to address after these changes are in place.</p>
<section id="capabilities" class="level3">
<h3 class="anchored" data-anchor-id="capabilities">Capabilities</h3>
<p>A mechanism is introduced by which backends can declare explicitly which features of DBI a particular connection supports. Examples for existing functionality that varies over backends include:</p>
<ul>
<li>Support for BLOBs (not available e.g.&nbsp;in Redshift).</li>
<li>Support for logical columns (not available e.g.&nbsp;in SQL Server or SQLite).</li>
<li>Support for named or nested transactions (not standardized).</li>
<li>Placeholder character to use in parameterized queries (different across databases).</li>
</ul>
<p>In the future, backends may also indicate:</p>
<ul>
<li>Whether asynchronous queries are supported (important for web development).</li>
<li>Whether the database supports SQL or a different query language (DBI currently assumes SQL).</li>
</ul>
<p>The list of possible capabilities will be maintained by DBI and {DBItest} will rely solely on these capabilities, foregoing the current <em>tweaking</em> mechanism. Users can in turn query these capabilities and act accordingly.</p>
</section>
<section id="separate-user-interface" class="level3">
<h3 class="anchored" data-anchor-id="separate-user-interface">Separate user interface</h3>
<p>As an evolution of the current approach, where users of DBI will often directly call methods that are mostly implemented by backends themselves, introduction of a separate user-facing API may be worthwhile. Based on plain functions and essentially providing a <a href="https://en.wikipedia.org/wiki/Facade_pattern">facade</a>, this user interface would be sufficient for the overwhelming majority of use cases. At the same time, such an approach should contribute to simpler code with less duplication in backend packages.</p>
<p>The new user interface performs tasks that are common to all database backends (e.g.&nbsp;validation of arguments), and calls methods provided by the backends, in some cases dependent on declared capabilities. Overall, this should lead to less code that needs to be reimplemented across backends. The decoupling of interfaces could help with iterative improvements, while guaranteeing stability for users. As an example, a <code>dbi_write_table()</code> function that optionally creates and writes data to a database table might encompass the following functionality:</p>
<ul>
<li>If the backend supports transactions:
<ul>
<li>Call <code>dbi_is_transacting()</code> to determine if the statement is occurring as part of a transaction.</li>
<li>Call <code>dbi_begin_transaction()</code> if it is not already part a transaction.</li>
<li>Use <code>dbi_begin_transaction(name = "...")</code> if the backend supports named transactions.</li>
</ul></li>
<li>Call <code>dbi_remove_table()</code> and/or <code>dbi_create_table()</code> if necessary.</li>
<li>Call <code>dbi_append_table()</code>.</li>
<li>Call <code>dbi_commit()</code> on success or <code>dbi_rollback()</code> on failure whenever transactions are supported.</li>
</ul>
<p>For appending rows to a table, <code>dbi_append_table()</code> might check if the backend supports streaming uploads or if SQL should be created for inserting rows. In the latter case, the SQL statement (or multiple statements for large tables) could be constructed using quoted literals obtained from <code>dbi_quote_literal()</code>. The backend could indicate the maximum supported length of a statement, so that splitting of large tables into multiple chunks can happen automatically.</p>
<p>As a final example, a backend supporting asynchronous operations might rely entirely on DBI for providing the corresponding blocking operations. The asynchronous procedure provided by the backend could automatically be wrapped by a DBI function that only returns upon completion.</p>
<p>Such a split API would allow for generics declared by {DBI} for interfacing with backends to remain frozen. To extend or alter the signature of a generic, a new generic can be added, using some form of versioning (e.g.&nbsp;with a numeric suffix, such as <code>dbAppendTable1()</code>, <code>dbAppendTable2()</code>, etc.). With such an architecture, arguments in generics could be declared explicitly, without relying on forwarding via <code>...</code>, as is done currently. The user is presented with a stable API with only backward-compatible changes, {DBI} internally decides which versions of a method to call. When a new version of a generic is introduced, {DBI} documents and proposes an upgrade path for backend implementers. In the long run this would also allow for transitioning to another object-oriented system such as S3 or <a href="https://github.com/RConsortium/OOP-WG/">R7</a> without introducing user-facing breaking changes.</p>
<p>This approach also enables support of rich callbacks: each function in the facade can notify listeners on entry and before returning. For example, a call to <code>dbi_connect()</code> would notify interested parties that a new connection has been established, and a call to <code>dbi_query()</code> issues callbacks with the query and the result. Potential use cases include:</p>
<ul>
<li>Logging as in {dblog}.</li>
<li>The <em>Connections</em> pane in RStudio.</li>
<li>Mocking (with hooks) as in {dittodb}.</li>
</ul>
<p>A versioning scheme could also be implemented for callbacks, keeping existing callbacks frozen while allowing for addition of new features that alter callback signatures.</p>
</section>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>I‚Äôd like to thank Jeroen Ooms and G√°bor Cs√°rdi for providing crucial infrastructure to support this and many other projects in the R ecosystem.</p>
<p>Thanks to the numerous contributors to the packages in the ‚ÄúMaintaining DBI‚Äù project in 2021:</p>
<ul>
<li>DBI: <a href="https://github.com/bwohl">@bwohl</a>, <a href="https://github.com/cboettig">@cboettig</a>, <a href="https://github.com/dcassol">@dcassol</a>, <a href="https://github.com/jawond">@jawond</a>, <a href="https://github.com/mmccarthy404">@mmccarthy404</a>, <a href="https://github.com/pnacht">@pnacht</a>, <a href="https://github.com/r2evans">@r2evans</a>, <a href="https://github.com/vituri">@vituri</a>, and <a href="https://github.com/zoushucai">@zoushucai</a>;</li>
<li>RSQLite: <a href="https://github.com/ablack3">@ablack3</a>, <a href="https://github.com/billy34">@billy34</a>, <a href="https://github.com/edwindj">@edwindj</a>, <a href="https://github.com/gaborcsardi">@gaborcsardi</a>, <a href="https://github.com/ggrothendieck">@ggrothendieck</a>, <a href="https://github.com/giocomai">@giocomai</a>, <a href="https://github.com/habilzare">@habilzare</a>, <a href="https://github.com/honghh2018">@honghh2018</a>, <a href="https://github.com/Jeff-Gui">@Jeff-Gui</a>, <a href="https://github.com/kevinushey">@kevinushey</a>, <a href="https://github.com/mgirlich">@mgirlich</a>, <a href="https://github.com/plantton">@plantton</a>, <a href="https://github.com/schuemie">@schuemie</a>, <a href="https://github.com/Shicheng-Guo">@Shicheng-Guo</a>, and <a href="https://github.com/tschoonj">@tschoonj</a>;</li>
<li>RPostgres: <a href="https://github.com/aleaficionado">@aleaficionado</a>, <a href="https://github.com/armenic">@armenic</a>, <a href="https://github.com/ateucher">@ateucher</a>, <a href="https://github.com/baderstine">@baderstine</a>, <a href="https://github.com/beralef">@beralef</a>, <a href="https://github.com/carlganz">@carlganz</a>, <a href="https://github.com/ColinFay">@ColinFay</a>, <a href="https://github.com/dcaud">@dcaud</a>, <a href="https://github.com/dpprdan">@dpprdan</a>, <a href="https://github.com/f-ritter">@f-ritter</a>, <a href="https://github.com/galachad">@galachad</a>, <a href="https://github.com/GitHubGeniusOverlord">@GitHubGeniusOverlord</a>, <a href="https://github.com/gontcharovd">@gontcharovd</a>, <a href="https://github.com/gtm19">@gtm19</a>, <a href="https://github.com/hadley">@hadley</a>, <a href="https://github.com/jakob-r">@jakob-r</a>, <a href="https://github.com/jeroen">@jeroen</a>, <a href="https://github.com/jkylearmstrong">@jkylearmstrong</a>, <a href="https://github.com/JSchoenbachler">@JSchoenbachler</a>, <a href="https://github.com/matthewgson">@matthewgson</a>, <a href="https://github.com/mgirlich">@mgirlich</a>, <a href="https://github.com/mmuurr">@mmuurr</a>, <a href="https://github.com/mskyttner">@mskyttner</a>, <a href="https://github.com/phedinkus">@phedinkus</a>, <a href="https://github.com/ppssphysics">@ppssphysics</a>, <a href="https://github.com/RakeshG1">@RakeshG1</a>, <a href="https://github.com/rickbpdq">@rickbpdq</a>, <a href="https://github.com/samiaab1990">@samiaab1990</a>, <a href="https://github.com/sawnaanwas">@sawnaanwas</a>, <a href="https://github.com/tomasjanikds">@tomasjanikds</a>, <a href="https://github.com/vspinu">@vspinu</a>, <a href="https://github.com/waynelapierre">@waynelapierre</a>, <a href="https://github.com/zmbc">@zmbc</a>, and <a href="https://github.com/zozlak">@zozlak</a>;</li>
<li>RMariaDB: <a href="https://github.com/bakiunal">@bakiunal</a>, <a href="https://github.com/dirkschumacher">@dirkschumacher</a>, <a href="https://github.com/hadley">@hadley</a>, <a href="https://github.com/jeroen">@jeroen</a>, <a href="https://github.com/Mosk915">@Mosk915</a>, <a href="https://github.com/noamross">@noamross</a>, <a href="https://github.com/paulmaunders">@paulmaunders</a>, <a href="https://github.com/retowyss">@retowyss</a>, <a href="https://github.com/rorynolan">@rorynolan</a>, <a href="https://github.com/twentytitus">@twentytitus</a>, <a href="https://github.com/verajosemanuel">@verajosemanuel</a>, <a href="https://github.com/wiligl">@wiligl</a>, <a href="https://github.com/Woosah">@Woosah</a>, and <a href="https://github.com/zoushucai">@zoushucai</a>.</li>
<li>DBItest: <a href="https://github.com/adamsma">@adamsma</a>, and <a href="https://github.com/michaelquinn32">@michaelquinn32</a>;</li>
</ul>
<p>Thanks also to Nicolas Bennett for reviewing and editing this blog post.</p>


</section>

 ]]></description>
  <guid>https://r-dbi.org/blog/dbi-3-4/</guid>
  <pubDate>Tue, 21 Dec 2021 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Maintaining DBI, 3/4</title>
  <dc:creator>Kirill M√ºller</dc:creator>
  <link>https://r-dbi.org/blog/dbi-3-3/</link>
  <description><![CDATA[ 




<section id="what-is-dbi" class="level2">
<h2 class="anchored" data-anchor-id="what-is-dbi">What is DBI?</h2>
<p>DBI stands for <strong>d</strong>ata<strong>b</strong>ase <strong>i</strong>nterface. The DBI package connects R to database management systems (DBMS). The goal of DBI is to provide a common interface for database access, regardless of the specific underlying DBMS. DBI works with a variety of DBMS, such as Postgres, MariaDB, and SQLite, through dedicated <a href="https://github.com/r-dbi/backends#readme">backend packages</a>. For first-time users I recommend starting with the new <a href="https://dbi.r-dbi.org/articles/DBI.html">introductory tutorial</a>.</p>
<p>The current version of DBI is 1.1.1. This blog post attempts to define the scope of the DBI project, summarizes recent developments in DBI and related packages, and showcases future work.</p>
</section>
<section id="scope-of-the-dbi-project" class="level2">
<h2 class="anchored" data-anchor-id="scope-of-the-dbi-project">Scope of the DBI project</h2>
<p>The DBI package is perfect for anyone looking to connect to a database, read/write entire tables, and/or execute SQL queries. DBI gives a direct access to the database driver, leaving more sophisticated data query and manipulation tasks to packages like <a href="https://dbplyr.tidyverse.org/">dbplyr</a>, <a href="https://github.com/ankane/dbx">dbx</a> and <a href="https://winvector.github.io/rquery/">rquery</a>.</p>
<p>The core DBI project in R provides an interface for databases, specified in textual form and via automated tests. The <a href="https://dbi.r-dbi.org/articles/spec.html">DBI specification</a> contains a detailed description of the methods provided by DBI. In summary, the interface covers:</p>
<ul>
<li><p>Discovery of tables, also in schemas</p></li>
<li><p>Reading/writing/creating/removing tables</p></li>
<li><p>Executing queries, fetching data (with parameters)</p></li>
<li><p>Safe quoting: low-level composition of queries</p></li>
<li><p>Transactions</p></li>
</ul>
<p>DBI should provide a way to ingest data of any type into R, at least in serialized form (e.g.&nbsp;string or <a href="https://en.wikipedia.org/wiki/Binary_large_object">blob</a>). It should offer a robust reliable interface for dependent packages; anything beyond this scope should be left to packages that extend DBI:</p>
<ul>
<li><p>arkdb: archival of database data</p></li>
<li><p>connection: integrate database connections with the RStudio IDE</p></li>
<li><p>dbplyr and rquery: generation of SQL queries</p></li>
<li><p>dbx: DBI extension for data manipulation</p></li>
<li><p>dittodb: mocking for databases</p></li>
<li><p>dm: relational data models (via dbplyr)</p></li>
<li><p>pool: connection pooling</p></li>
<li><p>sqlr: schema definition</p></li>
</ul>
<p>and many more.</p>
</section>
<section id="recent-developments-in-dbi" class="level2">
<h2 class="anchored" data-anchor-id="recent-developments-in-dbi">Recent developments in DBI</h2>
<p>This section discusses:</p>
<ul>
<li><p>the new DBI tutorials,</p></li>
<li><p>improvements for datetime data,</p></li>
<li><p>other notable changes,</p></li>
<li><p>the move to GitHub Actions.</p></li>
</ul>
<p>The first three items directly affect DBI users, the last item much less so. It is nevertheless an important investment in the stability of the DBI infrastructure.</p>
<section id="new-tutorials" class="level3">
<h3 class="anchored" data-anchor-id="new-tutorials">New tutorials</h3>
<p>James Wondrasek substantially expanded the ‚ÄúIntroduction to DBI‚Äù article and added a second article. DBI now features two tutorials. The <a href="https://dbi.r-dbi.org/articles/DBI.html">introduction</a> includes a walkthrough that describes connecting and querying a real database. The <a href="https://dbi.r-dbi.org/articles/DBI-advanced.html">‚ÄúAdvanced DBI usage‚Äù</a> tutorial shows more advanced examples of quoting and parameter binding. The tutorials are an important first-hand resource for new users.</p>
</section>
<section id="time-zones" class="level3">
<h3 class="anchored" data-anchor-id="time-zones">Time zones</h3>
<p>To date, it was only possible to work reliably with time zones when the database connection represented all times in UTC. This poses a few problems in practice:</p>
<ul>
<li><p>Not all databases store timestamps as UTC or with time zone offset, often local time is assumed by the data model.</p></li>
<li><p>Other systems often use the default setting for time zone, this harms interoperability of DBI in these cases.</p></li>
<li><p>Conversion of timestamps to dates via the SQL function <code>DATE</code> is only correct when the session time zone is set correctly.</p></li>
</ul>
<p>RMariaDB 1.1.0 and RPostgres 1.3.0 gained more robust support for datetime values. As proposed in the <a href="https://www.r-dbi.org/blog/dbi-3-2.html">previous blog post</a>, new arguments <code>timezone</code> and <code>timezone_out</code> were added. Both arguments should use Olson names such as <code>Europe/Berlin</code> or <code>America/New_York</code>, not time offsets like <code>+01:00</code>; the latter may change with daylight time savings season. If <code>timezone</code> is set to <code>NULL</code>, an attempt is made to detect the correct time zone on the database. Thanks to Philipp Schauberger for contributing the initial <code>timezone</code> argument for RMariaDB.</p>
<p>RSQLite does not natively support dates or times. A promising <a href="https://github.com/r-dbi/RSQLite/pull/333">pull request</a> is underway that implements support for treating numeric values as time offsets if the column type is declared in a specific way.</p>
</section>
<section id="notable-changes-to-dbi-backends" class="level3">
<h3 class="anchored" data-anchor-id="notable-changes-to-dbi-backends">Notable changes to DBI backends</h3>
<p>The following package versions were sent to CRAN since the last blog post:</p>
<ul>
<li>DBI 1.1.0 -&gt; 1.1.1 (<a href="https://dbi.r-dbi.org/news/">NEWS</a>)</li>
<li>RMariaDB 1.0.8 -&gt; 1.1.0 (<a href="https://rmariadb.r-dbi.org/news/">NEWS</a>)</li>
<li>RPostgres 1.2.0 -&gt; 1.3.1 (<a href="https://rpostgres.r-dbi.org/news/">NEWS</a>)</li>
<li>RSQLite 2.1.5 -&gt; 2.2.2 (<a href="https://rsqlite.r-dbi.org/news/">NEWS</a>)</li>
</ul>
<p>Highlights are:</p>
<ul>
<li><p>DBI: Two new tutorials; minor improvements to <code>dbQuoteLiteral()</code>, this is relevant for backends that don‚Äôt provide their own implementation.</p></li>
<li><p>RMariaDB: Better handling of data types and character encoding; minor tweaks to <code>dbBind()</code> and <code>dbQuoteLiteral()</code>.</p></li>
<li><p>RPostgres: The new <code>Redshift()</code> driver that allows downstream packages to distinguish between Postgres and Amazon RedShift (thanks Hadley Wickham); minor improvements for querying and passing date and time types, <code>postgresWaitForNotify()</code> contributed by Jamie Lentin.</p></li>
<li><p>RSQLite: <code>dbAppendTable()</code> is faster, strings and blobs can have virtually unlimited size (limit 2 GB), embedded SQLite library is now in version 3.34.</p></li>
<li><p>DBItest: understanding which tests failed is now simpler, also thanks to simpler backtraces; <code>test_some()</code> integrates with the dblog package and shows DBI methods called; established compatibility with testthat 3.0.0; better and more robust tests.</p></li>
<li><p>RKazam: Is now a template repository</p></li>
</ul>
<p>Thanks to Jeroen Ooms for maintaining Windows versions for the database libraries.</p>
</section>
<section id="qa-and-automation" class="level3">
<h3 class="anchored" data-anchor-id="qa-and-automation">QA and automation</h3>
<p>Automated tests are a crucial part of modern software engineering. These are often augmented with continuous integration (CI) services that run these tests regularly or with every change to the code. When I started working on DBI, Travis CI offered excellent continuous integration services for open-source repositories. Unfortunately, this is no longer the case: the free tier introduced a limit on CI build time, rendering it effectively unusable for DBI.</p>
<p><a href="https://github.com/features/actions">GitHub Actions</a> is a CI/CD platform tightly integrated with GitHub. It is somewhat simpler to set up, also for creating workflows that e.g.&nbsp;open a pull request. It is sufficient to add a YAML configuration file to a dedicated location in the repository. Each build automatically obtains a token that can be used to interact with the GitHub API. R support is provided by <a href="https://github.com/r-lib/actions">dedicated workflows and actions</a> contributed by RStudio. Check status is conveniently reported in detail with each pull request, and the checks run considerably faster due to higher concurrency.</p>
<p>Continuous integration for all packages in the project has moved to GitHub Actions. Cross-platform checks for all backends on the major operating systems were a bit challenging, because the tests require a live database. Thanks to Andrew Kane for providing GitHub actions that install database engines on all platforms, this greatly simplified the move.</p>
<p>Three more parts of the infrastructure were updated as part of the move:</p>
<ol type="1">
<li><p>The odbc and duckdb packages are now also checked when the DBItest package updates. This ensures that new or amended specifications do not break these packages. If you maintain a DBI backend that uses DBItest, get in touch for integrating your backend with these checks.</p></li>
<li><p>The <a href="https://github.com/r-dbi/backends#readme">list of DBI backends</a> is now continuously updated. Updates to backends are applied automatically. Every time a new backend is found, a pull request is opened.</p></li>
<li><p>A new <a href="https://github.com/r-dbi/RSQLite/pull/337">pull request</a> is opened in RSQLite when a new version of the SQLite library is available. This makes it much easier to keep the bundled SQLite version up to date.</p></li>
</ol>
</section>
</section>
<section id="future-work" class="level2">
<h2 class="anchored" data-anchor-id="future-work">Future work</h2>
<p>The last blog post already identified major milestones:</p>
<ul>
<li><p>query cancellation</p></li>
<li><p>testing on remote databases</p></li>
</ul>
<p>A triage of the contributed issues has identified the following additional major topics:</p>
<ul>
<li><p><code>immediate</code> argument to <code>dbSendQuery()</code> and <code>dbSendStatement()</code> for RMariaDB and RPostgres</p></li>
<li><p>performance of table import</p></li>
<li><p>reconnect if a database connection is lost</p></li>
</ul>
<p>Other minor issues include:</p>
<ul>
<li><p>SSL connections</p></li>
<li><p>authentication plugins</p></li>
<li><p>support for more data types: arrays, JSON, ‚Ä¶</p></li>
</ul>
<p>I‚Äôm planning to resolve most of the remaining issues in a final sprint. Some of these issues can be outsourced to other packages, according to the scope outlined in the previous sections, priority should be given to issues that must be resolved in the core packages. Future work might shift towards providing or improving useful extensions.</p>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>I‚Äôd like to thank James Wondrasek for creating the DBI tutorials and for a review of this blog post, Angelica Becerra for reviewing the material, and the numerous contributors to the packages in the ‚ÄúMaintaining DBI‚Äù project (DBI¬π, RSQLite¬≤, RPostgres¬≥, RMariaDB‚Å¥, and DBItest‚Åµ):</p>
<p><a href="https://github.com/abalter">@abalter</a>¬≥, <a href="https://github.com/alanpaulkwan">@alanpaulkwan</a>¬≤, <a href="https://github.com/AllenSuttonValocity">@AllenSuttonValocity</a>¬≥, <a href="https://github.com/altay-oz">@altay-oz</a>¬≥, <a href="https://github.com/anderic1">@anderic1</a>¬≤, <a href="https://github.com/andybeet">@andybeet</a>¬π, <a href="https://github.com/arencambre">@arencambre</a>‚Å¥, <a href="https://github.com/artemklevtsov">@artemklevtsov</a>¬≥, <a href="https://github.com/bastianilso">@bastianilso</a>‚Å¥, <a href="https://github.com/bczernecki">@bczernecki</a>¬π, <a href="https://github.com/Byggvir">@Byggvir</a>‚Å¥, <a href="https://github.com/Chrisjb">@Chrisjb</a>¬π, <a href="https://github.com/clementbfeyt">@clementbfeyt</a>‚Å¥, <a href="https://github.com/colearendt">@colearendt</a>¬π, <a href="https://github.com/daattali">@daattali</a>¬π, <a href="https://github.com/datawookie">@datawookie</a>¬π, <a href="https://github.com/dpprdan">@dpprdan</a>¬≥‚Åµ, <a href="https://github.com/elfatherbrown">@elfatherbrown</a>‚Å¥, <a href="https://github.com/EntwicklR">@EntwicklR</a>¬≤, <a href="https://github.com/ericemc3">@ericemc3</a>‚Å¥, <a href="https://github.com/formix">@formix</a>¬≥, <a href="https://github.com/fproske">@fproske</a>¬π, <a href="https://github.com/georgevbsantiago">@georgevbsantiago</a>¬π, <a href="https://github.com/GitHunter0">@GitHunter0</a>¬π, <a href="https://github.com/hadley">@hadley</a>¬≤¬≥, <a href="https://github.com/hmeleiro">@hmeleiro</a>¬π, <a href="https://github.com/hpages">@hpages</a>¬≤, <a href="https://github.com/imlijunda">@imlijunda</a>¬≥, <a href="https://github.com/inferiorhumanorgans">@inferiorhumanorgans</a>¬≥, <a href="https://github.com/jarauh">@jarauh</a>‚Å¥, <a href="https://github.com/jawond">@jawond</a>¬π, <a href="https://github.com/jeroen">@jeroen</a>¬≥, <a href="https://github.com/jimhester">@jimhester</a>¬π, <a href="https://github.com/jjesusfilho">@jjesusfilho</a>¬≥, <a href="https://github.com/jsilve24">@jsilve24</a>¬≤, <a href="https://github.com/kforner">@kforner</a>‚Å¥, <a href="https://github.com/kmishra9">@kmishra9</a>¬≤, <a href="https://github.com/Kodiologist">@Kodiologist</a>¬π¬≤, <a href="https://github.com/LaugeGregers">@LaugeGregers</a>¬≥, <a href="https://github.com/luispuerto">@luispuerto</a>¬≤, <a href="https://github.com/martinstuder">@martinstuder</a>‚Åµ, <a href="https://github.com/matteodelucchi">@matteodelucchi</a>‚Å¥, <a href="https://github.com/MaximumV">@MaximumV</a>¬π, <a href="https://github.com/mbannert">@mbannert</a>¬≥, <a href="https://github.com/mbedward">@mbedward</a>¬≥, <a href="https://github.com/mgirlich">@mgirlich</a>¬≤, <a href="https://github.com/mlamias">@mlamias</a>¬π, <a href="https://github.com/mllg">@mllg</a>¬π, <a href="https://github.com/mmuurr">@mmuurr</a>¬≥, <a href="https://github.com/momeara">@momeara</a>¬≥, <a href="https://github.com/MonteShaffer">@MonteShaffer</a>‚Å¥, <a href="https://github.com/Mosk915">@Mosk915</a>‚Å¥, <a href="https://github.com/nfultz">@nfultz</a>¬≤, <a href="https://github.com/norquanttech">@norquanttech</a>¬≥, <a href="https://github.com/OMalytics">@OMalytics</a>¬≥, <a href="https://github.com/oriolcmp">@oriolcmp</a>‚Å¥, <a href="https://github.com/Osc2wall">@Osc2wall</a>‚Å¥, <a href="https://github.com/psychobas">@psychobas</a>¬≤, <a href="https://github.com/randyzwitch">@randyzwitch</a>‚Åµ, <a href="https://github.com/rcfree">@rcfree</a>¬≤, <a href="https://github.com/rnorberg">@rnorberg</a>¬π, <a href="https://github.com/rodriguesk">@rodriguesk</a>¬≤, <a href="https://github.com/rossholmberg">@rossholmberg</a>‚Å¥, <a href="https://github.com/Sahil308">@Sahil308</a>‚Å¥, <a href="https://github.com/samuel-cs4">@samuel-cs4</a>‚Å¥, <a href="https://github.com/schuemie">@schuemie</a>¬≤, <a href="https://github.com/shutinet">@shutinet</a>¬≤, <a href="https://github.com/splaisan">@splaisan</a>¬≤, <a href="https://github.com/Trowic">@Trowic</a>‚Å¥, <a href="https://github.com/verajosemanuel">@verajosemanuel</a>‚Å¥, <a href="https://github.com/VictorYammouni">@VictorYammouni</a>¬π, <a href="https://github.com/vigyoyo">@vigyoyo</a>‚Å¥, <a href="https://github.com/vikram-rawat">@vikram-rawat</a>¬≥, <a href="https://github.com/vspinu">@vspinu</a>¬≥, <a href="https://github.com/warnes">@warnes</a>¬≥, <a href="https://github.com/wiligl">@wiligl</a>¬≤, <a href="https://github.com/ycphs">@ycphs</a>‚Å¥, and <a href="https://github.com/zyxdef">@zyxdef</a>¬π.</p>


</section>

 ]]></description>
  <guid>https://r-dbi.org/blog/dbi-3-3/</guid>
  <pubDate>Wed, 20 Jan 2021 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Maintaining DBI, 2/4</title>
  <dc:creator>Kirill M√ºller</dc:creator>
  <link>https://r-dbi.org/blog/dbi-3-2/</link>
  <description><![CDATA[ 




<section id="what-is-dbi" class="level2">
<h2 class="anchored" data-anchor-id="what-is-dbi">What is DBI?</h2>
<p>DBI stands for <strong>d</strong>ata<strong>b</strong>ase <strong>i</strong>nterface, and DBI is a package for connecting to database management systems (DBMS). The goal of DBI is to provide a common interface for accessing a database, regardless of the specific underlying DBMS.</p>
<p>DBI works with a variety of DBMS, such as Postgres, MariaDB, and SQLite, allowing users to focus on the specifics of their project instead of setting up the infrastructure for data import and export.</p>
<p>The DBI package is perfect for anyone looking to connect to a database, read/write entire tables, and/or execute SQL queries. DBI offers more control to the user than packages such as <a href="https://dbplyr.tidyverse.org/">{dbplyr}</a>.</p>
<p>The current version of DBI is 1.1.0. This blog post summarizes recent developments in DBI and related packages.</p>
</section>
<section id="specification-of-immediate-argument-to-dbsendquery-and-friends" class="level2">
<h2 class="anchored" data-anchor-id="specification-of-immediate-argument-to-dbsendquery-and-friends">Specification of <code>immediate</code> argument to <code>dbSendQuery()</code> and friends</h2>
<p>Tom Nolan raised an <a href="https://github.com/r-dbi/DBI/issues/268">issue on GitHub</a>, requesting to specify details of the behavior of query execution. It became apparent that the DBI specification did not account for database drivers where the execution path is substantially different for queries with or without parameters. Recent version of DBI mandated the use of a prepared statement or query for everything.</p>
<p>Similar problems have been noted in MariaDB, Postgres and SQL Server (when accessed through {odbc}): some statements cannot be executed as prepared statements, or <a href="https://github.com/r-dbi/RPostgres/issues/185">prepared statements are disabled</a>. Over the course of several months, the details of the required extension of this API were fleshed out.</p>
<p>The <code>dbSendQuery()</code>, <code>dbGetQuery()</code>, <code>dbSendStatement()</code> and <code>dbExecute()</code> methods gain a new <code>immediate</code> argument. By setting this argument to <code>TRUE</code>, a direct query is created, allowing to execute queries that could not be run previously. Arguably, this is one of those obscure features that are not noted until they are missed.</p>
<p>It is up to the individual backends to add support for this argument. The default value should be made backward-compatible with the previous version of DBI 1.0.0. It has already been implemented in the {odbc} package. Plans to implement this feature in both {RMariaDB} and {RPostgres} are underway.</p>
<section id="examples-using-immediate" class="level3">
<h3 class="anchored" data-anchor-id="examples-using-immediate">Examples using <code>immediate</code></h3>
<pre><code>library(DBI)
con &lt;- dbConnect(odbc::odbc(), dsn = "SQLServerConnection")

# Create local temporary tables:
# Did not work before, temporary table was removed immediately.
dbExecute(con, "CREATE TABLE #temp (a integer)", immediate = TRUE)
dbExecute(con, "INSERT INTO #temp VALUES (1)", immediate = TRUE)

# Show execution plan:
# Did not work before, execution plan was never shown
dbExecute(con, "SET SHOWPLAN_TEXT ON", immediate = TRUE)
dbGetQuery(con, "SELECT * FROM #temp WHERE a &gt; 0")
dbExecute(con, "SET SHOWPLAN_TEXT OFF", immediate = TRUE)</code></pre>
</section>
</section>
<section id="connector-objects" class="level2">
<h2 class="anchored" data-anchor-id="connector-objects">Connector objects</h2>
<p>The existing method in DBI has been to create the driver object and then call <code>dbConnect()</code> with the connection arguments. However there are times when a user may need to do the following:</p>
<ul>
<li>Separate connection arguments from establishing a connection</li>
<li>Serialize the connector to file in order to establish the same connection later</li>
<li>Maintain multiple connectors in a list for testing different DBMS</li>
</ul>
<p>In order to address these use cases, users now have the ability to create a ‚Äúconnector object‚Äù that combines the driver and connection arguments, allowing the user to call <code>dbConnect()</code> without additional arguments. This feature is implemented in {DBI}, and works out of the box for all DBI backends.</p>
<section id="example" class="level3">
<h3 class="anchored" data-anchor-id="example">Example</h3>
<pre><code>library(DBI)

# Old way:
drv &lt;- RSQLite::SQLite()
con &lt;- dbConnect(drv, dbname = ":memory:")
dbDisconnect(con)

# New connector object:
cnr &lt;- new("DBIConnector",
  .drv = RSQLite::SQLite(),
  .conn_args = list(dbname = ":memory:")
)
cnr

## &lt;DBIConnector&gt;&lt;SQLiteDriver&gt;
## Arguments:
## $dbname
## [1] ":memory:"

con &lt;- dbConnect(cnr)
dbDisconnect(con)</code></pre>
<p>In addition, arguments can be functions, a useful feature for passwords and other sensitive connection data.</p>
</section>
</section>
<section id="logging-with-the-dblog-package" class="level2">
<h2 class="anchored" data-anchor-id="logging-with-the-dblog-package">Logging with the {dblog} package</h2>
<p>When using applications in production, keeping logs is an invaluable part of a sound infrastructure. The new <a href="https://github.com/r-dbi/dblog">{dblog}</a> package is designed to be as simple as possible. It can be used as a standalone package or in conjunction with packages like {dbplyr}.</p>
<p>{dblog} helps both with troubleshooting as well as auditing the queries that that are used to access a database. Similar to Perl‚Äôs DBI::log, the goal of {dblog} is to implement logging for arbitrary DBI backends.</p>
<p>{dblog} is straightforward in its use. Start by initializing a logging driver using <code>dblog()</code> prior to connecting to a database management system. All calls to DBI methods are logged and by default printed to the console (or redirected to a file). The entirety of the logging output is runnable R code, so users can copy, paste, and execute the logging code for debugging.</p>
<section id="using-dblog-to-connect-to-sqlite" class="level3">
<h3 class="anchored" data-anchor-id="using-dblog-to-connect-to-sqlite">Using <code>dblog()</code> to connect to SQLite</h3>
<pre><code>library(dblog)

drv &lt;- dblog(RSQLite::SQLite())
#&gt; drv1 &lt;- RSQLite::SQLite()</code></pre>
</section>
<section id="all-calls-to-dbi-methods-are-logged-by-default-to-the-console" class="level3">
<h3 class="anchored" data-anchor-id="all-calls-to-dbi-methods-are-logged-by-default-to-the-console">All calls to DBI methods are logged, by default to the console</h3>
<pre><code>conn &lt;- dbConnect(drv, file = ":memory:")
#&gt; conn1 &lt;- dbConnect(drv1, file = ":memory:")

dbWriteTable(conn, "iris", iris[1:3, ])
#&gt; dbWriteTable(conn1, name = "iris", value = structure(list(Sepal.Length = c(5.1, 4.9, 
#&gt; 4.7), Sepal.Width = c(3.5, 3, 3.2), Petal.Length = c(1.4, 1.4, 1.3), Petal.Width = c(0.2, 
#&gt; 0.2, 0.2), Species = structure(c(1L, 1L, 1L), .Label = c("setosa", "versicolor", 
#&gt; "virginica"), class = "factor")), row.names = c(NA, 3L), class = "data.frame"), overwrite = FALSE, 
#&gt;     append = FALSE)

data &lt;- dbGetQuery(conn, "SELECT * FROM iris")
#&gt; dbGetQuery(conn1, "SELECT * FROM iris")
#&gt; ##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
#&gt; ## 1          5.1         3.5          1.4         0.2  setosa
#&gt; ## 2          4.9         3.0          1.4         0.2  setosa
#&gt; ## 3          4.7         3.2          1.3         0.2  setosa

dbDisconnect(conn)
#&gt; dbDisconnect(conn1)

data
#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
#&gt; 1          5.1         3.5          1.4         0.2  setosa
#&gt; 2          4.9         3.0          1.4         0.2  setosa
#&gt; 3          4.7         3.2          1.3         0.2  setosa</code></pre>
<p>This also works in scenarios where DBI is used under the hood by other packages like <a href="https://dbplyr.tidyverse.org/">dbplyr</a> or <a href="https://tidymodels.github.io/tidypredict/">tidypredict</a>. The log will represent the DBI operations issued, which allows for a better understanding of the internals.</p>
</section>
</section>
<section id="testing-your-infrastructure-for-dbi-compatibility" class="level2">
<h2 class="anchored" data-anchor-id="testing-your-infrastructure-for-dbi-compatibility">Testing your infrastructure for DBI compatibility</h2>
<p>DBItest (on CRAN in version 1.7.0) is currently geared towards usage as part of a package‚Äôs test suite. With some effort it is possible to test a database backend against a custom database. This can help verify that your database installation gives expected results when accessed with DBI with specific connection arguments. The <a href="https://dbitest.r-dbi.org/articles/DBItest.html#external-testing">DBItest article</a> contains a new section that describes how to achieve this, including a primer on using {dblog} to understand the cause of test failures.</p>
</section>
<section id="a-list-of-dbi-backends" class="level2">
<h2 class="anchored" data-anchor-id="a-list-of-dbi-backends">A list of DBI backends</h2>
<p>The new <a href="https://github.com/r-dbi/backends">backends</a> repository lists all known DBI backends, as retrieved via a code search on GitHub. The list is available in the README, and as a static web API for programmatic processing.</p>
</section>
<section id="better-handling-of-time-zones" class="level2">
<h2 class="anchored" data-anchor-id="better-handling-of-time-zones">Better handling of time zones</h2>
<p>Time zones are used to convert between <em>absolute</em> time and <em>civil</em> time, where absolute time exists independent of human-created measures such as calendars, days, and dates, whereas civil time is comprised of years, months, days, hours, minutes, and seconds. For a more in-depth reading on absolute time, civil time, and time zones, please read this excerpt from the <a href="https://github.com/r-dbi/odbc/blob/7b35549f9df935e1d132f6221860f87a6eb64ef6/src/cctz/README.md">ODBC README</a>.</p>
<p>For programming and data analysis, accurate handling time zones is crucial. {odbc} has set an example for how to handle time zones through the inclusion of <code>timezone</code> and <code>timezone_out</code> arguments to <code>dbConnect()</code>. The <code>timezone</code> argument controls the server time zone, which may be different from UTC. The <code>timezone_out</code> argument specifies the time zone to use for displaying times.</p>
<p>This strategy gives the user control over datetime information passed on to and retrieved from the database. Both arguments in combination should be able to support a broad variety of use cases and server setups. {RMariaDB} and {RPostgres} will incorporate this strategy with their next CRAN release. {RPostgres} already has gained a <code>timezone</code> argument in its <code>dbConnect()</code> method.</p>
</section>
<section id="window-function-support-in-rsqlite" class="level2">
<h2 class="anchored" data-anchor-id="window-function-support-in-rsqlite">Window function support in {RSQLite}</h2>
<p>RSQLite 2.1.4 and later includes sqlite &gt;= 3.29.0, which introduces support for window functions.</p>
<pre><code>library(tidyverse)
library(dbplyr)

tbl &lt;- memdb_frame(a = rep(1:2, 5), b = 1:10)

tbl %&gt;% 
  group_by(a) %&gt;%
  window_order(b) %&gt;% 
  mutate(c = cumsum(b)) %&gt;% 
  ungroup()

## # Source:     lazy query [?? x 3]
## # Database:   sqlite 3.30.1 [:memory:]
## # Ordered by: b
##        a     b     c
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1     1     1     1
##  2     1     3     4
##  3     1     5     9
##  4     1     7    16
##  5     1     9    25
##  6     2     2     2
##  7     2     4     6
##  8     2     6    12
##  9     2     8    20
## 10     2    10    30</code></pre>
</section>
<section id="cii-best-practices-badges-for-all-repos" class="level2">
<h2 class="anchored" data-anchor-id="cii-best-practices-badges-for-all-repos">CII ‚Äúbest practices‚Äù badges for all repos</h2>
<p>CII ‚Äúbest practices‚Äù have been implemented for {DBItest}, {RMariaDB}, {RPostgres} and {RSQLite}. The {DBItest} repository has a brand-new badge, the badges for the other repositories will follow suit.</p>
</section>
<section id="package-updates" class="level2">
<h2 class="anchored" data-anchor-id="package-updates">Package updates</h2>
<p>The following package versions were sent to CRAN in conjunction with this blog post:</p>
<ul>
<li>DBI 1.1.0 (<a href="https://dbi.r-dbi.org/news/">NEWS</a>)</li>
<li>DBItest 1.7.0 (<a href="https://dbitest.r-dbi.org/news/">NEWS</a>)</li>
<li>RMariaDB 1.0.8 (<a href="https://rmariadb.r-dbi.org/news/">NEWS</a>)</li>
<li>RPostgres 1.2.0 (<a href="https://rpostgres.r-dbi.org/news/">NEWS</a>)</li>
<li>RSQLite 2.1.5 (<a href="https://rsqlite.r-dbi.org/news/">NEWS</a>)</li>
</ul>
<p>Before that, minor updates of the database backend packages were necessary to comply with stricter CRAN checks and toolchain updates.</p>
</section>
<section id="future-work" class="level2">
<h2 class="anchored" data-anchor-id="future-work">Future work</h2>
<p>The remainder of the blog post discusses future directions for DBI and the backend packages.</p>
<section id="dbi-tutorials" class="level3">
<h3 class="anchored" data-anchor-id="dbi-tutorials">DBI tutorials</h3>
<p>Improving documentation is a priority. DBI is still lacking an up-to-date tutorial with a low entry bar that helps users connect to their database and execute queries. The updated <a href="https://dbi.r-dbi.org/">README</a> is a little step forward, but a slightly more comprehensive versions with link to more detailed information would be helpful.</p>
</section>
<section id="terraforming-databases" class="level3">
<h3 class="anchored" data-anchor-id="terraforming-databases">Terraforming databases</h3>
<p>Now that using DBItest to test backends against custom infrastructure is understood, it becomes easier to enhance tests so that not only pristine setups are tested, but also databases with nonstandard settings for time zone, character encoding or collation. <a href="https://www.terraform.io/">Terraform</a> helps automating the setup of databases of different flavors on cloud providers such as Azure or Google Cloud. The desired state of computing infrastructure is specified in a declarative way. This allows testing a much broader variety of databases and configurations, without maintaining expensive infrastructure: databases can be spun up when needed and torn down when done.</p>
<p>It would be helpful to have a selection of open-source and commercial databases in different configuration settings ready for testing.</p>
</section>
<section id="query-cancellation" class="level3">
<h3 class="anchored" data-anchor-id="query-cancellation">Query cancellation</h3>
<p>Currently, {odbc} and many other backends freeze while a query is executed. It is easy to underestimate the runtime of a query, or to accidentally execute a query that is running too long. This severely hampers interactive workflows: a frozen R session means forcibly restarting R, or worse, the development environment.</p>
<p>Mateusz ≈ª√≥≈Çtak has contributed a <a href="https://github.com/r-dbi/RPostgres/pull/193">pull request</a> that implements support for graceful query cancellation in {RPostgres}. <a href="https://github.com/r-dbi/odbc/issues/312">Initial research</a> suggests that for {odbc} it may be possible to implement this in a similar fashion. It remains to be seen if an implementation is viable, and if the database libraries used by {RMariaDB} and {RSQLite} support this mode of operation.</p>
</section>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>I‚Äôd like to thank Katharina Brunner and Jesse Mostipak for help with composing this blog post.</p>


</section>

 ]]></description>
  <guid>https://r-dbi.org/blog/dbi-3-2/</guid>
  <pubDate>Thu, 19 Dec 2019 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Maintaining DBI, 1/4</title>
  <dc:creator>Kirill M√ºller</dc:creator>
  <link>https://r-dbi.org/blog/dbi-3-1/</link>
  <description><![CDATA[ 




<p>Much earlier this year my proposal for the third R Consortium project for working on DBI has been accepted. DBI is a set of virtual functions declared in the <em>DBI</em> package. Communication with the database is implemented by <em>DBI backends</em>, packages that import <em>DBI</em> and implement its methods. A common interface is helpful for both users and backend implementers. Users, including package developers for DBMS-agnostic packages, need to memoize only one set of functions. Backend developers can focus on functionality instead of design decisions, and can benefit from a large base of potential users right from the start.</p>
<p>I‚Äôm grateful for the trust, and will do my best to make the ‚ÄúMaintaining DBI‚Äù project a success. For this round, the main goals are: maintain, enhance, disseminate. The project is delayed mostly becase I grossly underestimated how much time and energy it would take to set up <a href="http://cynkra.com">cynkra</a>. The new joint venture with Christoph Sax consults businesses and organizations on matters related to R, statistics, data, and software. We are strongly committed to R and open-source software, and more priority will be given the ‚ÄúMaintaining DBI‚Äù project next year.</p>
<p>This blog post, much later than planned, summarizes the efforts of the past year: presentations at meetups, the ‚ÄúCore Infrastructure Initiative‚Äù badge, and activity in the various repositories of the <a href="https://github.com/r-dbi">r-dbi</a> GitHub organization. I‚Äôll repeat the big picture issues from the proposal and present plans for future development.</p>
<section id="presentations-at-meetups" class="level2">
<h2 class="anchored" data-anchor-id="presentations-at-meetups">Presentations at meetups</h2>
<p>I presented DBI at the <a href="https://www.meetup.com/Berlin-R-Users-Group/">Berlin R user group</a>, at the <a href="https://amsterdam2018.satrdays.org/">amstRdays</a>, and at the <a href="https://zurich-r-user-group.github.io/index.html">Zurich R meetup</a>. The presentation in Berlin made me realize that a progress report isn‚Äôt that helpful for a general audience. The Zurich version of the presentation featured a DBI intro also suitable for new users, merely highlighting recent developments. <a href="https://bit.ly/2wFJix3">These slides</a>, and the <a href="https://solutions.posit.co/connections/db/r-packages/dbi/">intro at db.rstudio.com</a> seem to be the most recent general-purpose introduction materials available. I think an entry-level tutorial would be a good fit for a DBI vignette.</p>
</section>
<section id="cii-badge" class="level2">
<h2 class="anchored" data-anchor-id="cii-badge">CII badge</h2>
<p>From <a href="https://bestpractices.coreinfrastructure.org/en" class="uri">https://bestpractices.coreinfrastructure.org/en</a>:</p>
<blockquote class="blockquote">
<p>The Linux Foundation (LF) Core Infrastructure Initiative (CII) Best Practices badge is a way for Free/Libre and Open Source Software (FLOSS) projects to show that they follow best practices. Projects can voluntarily self-certify, at no cost, by using this web application to explain how they follow each best practice. The CII Best Practices Badge is inspired by the many badges available to projects on GitHub. Consumers of the badge can quickly assess which FLOSS projects are following best practices and as a result are more likely to produce higher-quality secure software.</p>
</blockquote>
<p>The CII badge can be obtained after a self-certification process that comprises ~70 soft and hard questions about the project around the following topics:</p>
<ul>
<li>Basics: Project URLs, license, documentation</li>
<li>Change Control: Version control and version numbers</li>
<li>Reporting: Tracking issues and vulnerabilities</li>
<li>Quality: Build and test system, best practices</li>
<li>Security (software)</li>
<li>Analysis (static and dynamic)</li>
</ul>
<p>After completing the process, projects are entitled to wear a badge like the one below for the DBI project:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://bestpractices.coreinfrastructure.org/projects/1882"><img src="https://bestpractices.coreinfrastructure.org/projects/1882/badge.svg" class="img-fluid figure-img" alt="OpenSSF Best Practices"></a></p>
<figcaption>OpenSSF Best Practices</figcaption>
</figure>
</div>
<p>A click on the badge takes you to the detailed assessment. In addition to the badge, completing the self-certification allows the maintainer to rethink if workflows and practices can be improved.</p>
<p>DBI is currently has the ‚Äúpassing‚Äù status, the backend packages and <em>DBItest</em> will follow. I have compiled the changes that were necessary to obtain that status below. It appears to be much more difficult but not impossible to obtain the ‚Äúsilver‚Äù status.</p>
<section id="necessary-changes-to-the-dbi-package" class="level3">
<h3 class="anchored" data-anchor-id="necessary-changes-to-the-dbi-package">Necessary changes to the DBI package</h3>
<p>Several files had to be added or updated:</p>
<ol type="1">
<li><a href="https://github.com/r-dbi/DBI/blob/master/.github/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a>: This file describes how to contribute to the project. A link to this file is available when you open a new issue. The function <code>usethis::use_tidy_contributing()</code> created the files which I tweaked a bit.</li>
<li><a href="https://github.com/r-dbi/DBI/blob/master/LICENSE.md"><code>LICENSE.md</code></a>: The full license terms need to be available as part of the project. To create the file, I <a href="https://github.com/r-lib/usethis/pull/472">contributed</a> <code>usethis::use_lgpl_2.1_license()</code>. Because CRAN discourages redistribution of copies of standard license texts in packages, the file has been added to <code>.Rbuildignore</code>. This makes the file available in the GitHub repository, but not package file on CRAN.</li>
<li><a href="https://github.com/r-dbi/DBI#readme"><code>README.md</code></a>: Added missing installation instructions.</li>
</ol>
<p>Though not on the CII badge checklist, I also added:</p>
<ol type="1">
<li><p><a href="https://github.com/r-dbi/DBI/blob/master/.github/ISSUE_TEMPLATE.md"><code>ISSUE_TEMPLATE.md</code></a>: pre-populates the issue description when opening a new issue. This is a tweaked version of the file provided by <code>usethis::use_tidy_issue_template()</code>.</p></li>
<li><p><a href="https://github.com/r-dbi/DBI/blob/master/.github/CODE_OF_CONDUCT.md"><code>CODE_OF_CONDUCT.md</code></a>: The default file as added by <code>usethis::use_code_of_conduct()</code>.</p></li>
</ol>
<p>One badge still had an HTTP image source, after changing it to HTTPS the criterion that the website needs to use TLS was satisfied.</p>
<p>Establishing a process for reporting code vulnerabilities was perhaps the most challenging part. It seems unclear if it applies to R packages at all, in particular to an interface-only package such as DBI. The solution was to add a link with text to the project page <a href="https://dbi.r-dbi.org" class="uri">https://dbi.r-dbi.org</a>, asking to send an e-mail and await further instructions.</p>
</section>
</section>
<section id="future-development" class="level2">
<h2 class="anchored" data-anchor-id="future-development">Future development</h2>
<p>The principal roadmap for future development has been outlined in the project proposal. There are both ‚Äúhard‚Äù and ‚Äúsoft‚Äù issues to solve, repeated below, with comments based on experience from the past year.</p>
<section id="hard-issues" class="level3">
<h3 class="anchored" data-anchor-id="hard-issues">‚ÄúHard‚Äù issues</h3>
<ol type="1">
<li><p>The test suite for the DBI specificaton in <code>DBItest</code> is currently designed to run as part of the package checks. The next step is to support running the test suite against a particular R + DBMS installation, to ensure that code interoperating with that DBMS in that environment runs as expected.</p>
<ul>
<li>Shouldn‚Äôt be too hard, but need to keep the second ‚Äúsoft‚Äù issue in mind.</li>
</ul></li>
<li><p>Users expect the hard disk or the DBMS to be the limiting factor for loading data, but DBI still lacks a consistent interface for fast data import.</p>
<ul>
<li>The new <a href="https://cran.r-project.org/package=arkdb"><em>arkdb</em> package</a> offers a dedicated interface for importing data, I still think this functionality should better live there (or elsewhere).</li>
</ul></li>
<li><p>The syntax for query placeholders currently depends on the DBMS. A consistent interface would be useful, in particular for implementers of packages that compute on the database.</p>
<ul>
<li>This has already caused some confusion. Shouldn‚Äôt be too hard either, but requires a compatibility mode so that existing code doesn‚Äôt break.</li>
</ul></li>
<li><p>The <code>RPostgres</code> package now has special handling for geometry data. A generic extension to arbitrary data types via hooks would allow e.g.&nbsp;returning JSON data directly as a <code>"json"</code> class without user-initiated manual conversion.</p>
<ul>
<li>This seems to be a bigger problem, requiring some thought and design.</li>
</ul></li>
</ol>
</section>
<section id="soft-issues" class="level3">
<h3 class="anchored" data-anchor-id="soft-issues">‚ÄúSoft‚Äù issues</h3>
<ol type="1">
<li><p>Some users reported installation problems on specific architectures, or connectivity problems with certain databases, or other specific issues. Making the new backends accessible for various combinations of OS/hardware, software, and configuration, will help the adoption of the new packages.</p>
<ul>
<li>I remember seeing many SSL and timezone issues, as well as genuine bugs like the representation of times before 1970 on Windows. Expect some progress for the second blog post.</li>
</ul></li>
<li><p>The internal architecture of the DBI specification in <code>DBItest</code> requires a bit of reworking. Currently, it is difficult to understand a test failure without inspecting the source code of <code>DBItest</code>. It is difficult to locate the source of a failure in the specification and in the code. Ideally, each test failure would come with a precise link to the part of the specification that is violated, and with a simple sequence of DBI method calls that allow replicating the failure externally.</p>
<ul>
<li>That code I wrote 1-2 years ago requires some attention‚Ä¶</li>
</ul></li>
<li><p>The communication related to the projects has been rather terse so far. The new website <a href="https://r-dbi.org" class="uri">https://r-dbi.org</a> can host blog posts highlighting different aspects of DBI, and serve as a resource for advice on connecting R with databases and computing on the database. This includes coordination and support for developments around DBI like <em>sqlr</em>, an interface for data definition statements on top of DBI.</p>
<ul>
<li>Together with the new <a href="https://github.com/terrytangyuan/ctv-databases">Databases CRAN Task View</a> maintained by Yuan (Terry) Tang and <a href="https://solutions.posit.co/connections/db/" class="uri">https://solutions.posit.co/connections/db/</a>, the <a href="https://r-dbi.org" class="uri">https://r-dbi.org</a> should become a viable resource for new and experienced users alike. New users should be directed to tutorials and introductory material, whereas experienced users should expect to find pointers to solve the most common problems. The role of each of these websites remains to be shaped, some overlap may be desired.</li>
</ul></li>
<li><p>All operations on DBI currently block until a result is available or the DBMS has indicated completion. Asynchronous operations allow parallel processing of multiple queries or statements, however some research is necessary to understand to what extent this can be supported realistically in DBI and for the existing backends.</p>
<ul>
<li>Additional arguments to <code>dbConnect()</code>, like the new <code>check_interrupts</code> argument <a href="https://github.com/r-dbi/RPostgres/pull/193">contributed to <em>RPostgres</em> by Mateusz ≈ª√≥≈Çtak</a>, are an option to experiment with asynchronous processing without disrupting existing code.</li>
</ul></li>
</ol>
<p>These lists are not comprehensive, new issues may surface over time, or the importance of issues mentioned above may fade.</p>
</section>
</section>
<section id="outlook-next-blog-post" class="level2">
<h2 class="anchored" data-anchor-id="outlook-next-blog-post">Outlook: next blog post</h2>
<p>The ‚ÄúMaintaining DBI‚Äù project is driven by blog posts. I promised four blog posts, describing the ongoing maintenance and development.</p>
<p>For the next iteration, I plan to improve documentation, do a release round for all packages, furnish more packages with a CII badge, review several new packages that build on top of <em>DBI</em>, and improve my responsiveness.</p>
<p>A Walkthrough for first-time DBI users seems to be the highest priority, perhaps accompanied by an online course. Other documentation improvements mostly will address <a href="https://r-dbi.org" class="uri">https://r-dbi.org</a>.</p>
<p>The following is an excerpt of changes in the forthcoming CRAN releases of the DBI packages:</p>
<ul>
<li><em>RSQLite</em>: window functions!</li>
<li><em>RMariaDB</em>: better handling for time zones</li>
<li><em>DBItest</em>: minor improvements</li>
</ul>
<p>New packages worth reviewing include:</p>
<ul>
<li><a href="https://cran.r-project.org/package=arkdb"><em>arkdb</em></a>: Consistent (and fast?) import and export</li>
<li><a href="https://cran.r-project.org/package=flobr"><em>flobr</em></a>: Converting files to blobs and back</li>
<li><a href="https://github.com/nbenn/sqlr"><em>sqlr</em></a>: SQLAlchemy-like DSL for data definition, work in progress</li>
<li><a href="https://cran.r-project.org/package=dbplot"><em>dbplot</em></a>: Plotting from the database</li>
<li>and many others.</li>
</ul>
<p>Adding CII badges for the backend packages and <em>DBItest</em> will give a more consistent appearance of the entire project.</p>
<p>As a New Year‚Äôs resolution, I pledge to do a better job as package maintainer for <em>DBI</em> and related packages. I reserved a few hours each Monday to respond to issues raised on GitHub and other channels (<a href="https://stackoverflow.com/">SO</a>, <a href="https://community.rstudio.com/">RStudio Community</a>, Twitter, and the somewhat underappreciated <a href="https://stat.ethz.ch/mailman/listinfo/r-sig-db">R-SIG-DB mailing list</a>). CI builds on Travis and AppVeyor also require occasional intervention. The remaining time will be spent on resolving known problems.</p>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>Thanks to all contributors to <em>DBI</em> and the other projects in the <a href="https://github.com/r-dbi">r-dbi organization</a>!</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://krlmlr.github.io/dbi-slides/2018-09-zurich-meetup/img/contributors.svg" class="img-fluid figure-img"></p>
<figcaption>DBI contributors</figcaption>
</figure>
</div>


</section>

 ]]></description>
  <guid>https://r-dbi.org/blog/dbi-3-1/</guid>
  <pubDate>Mon, 31 Dec 2018 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Done ‚ÄúEstablishing DBI‚Äù!?</title>
  <dc:creator>Kirill M√ºller</dc:creator>
  <link>https://r-dbi.org/blog/dbi-2-final/</link>
  <description><![CDATA[ 




<p>The ‚ÄúEstablishing DBI‚Äù project, funded by the R consortium, started about a year ago. It includes the completion of two new backends, <em>RPostgres</em> and <em>RMariaDB</em>, and a quite a few interface extensions and specifications. Learn more about DBI, R‚Äôs database interface, on <a href="https://r-dbi.org" class="uri">https://r-dbi.org</a>.</p>
<p>This blog post showcases only the visible changes, a substantial amount of work went into extending the DBI specification and making the three open-source database backends compliant to it. After describing the release of the two new backends <em>RMariaDB</em> and <em>RPostgres</em>, I‚Äôll be discussing the following improvements:</p>
<ul>
<li>Consistent support for accessing tables in schemas</li>
<li>Quoting literal values, in addition to strings and identifiers</li>
<li>More fine-grained creation of tables</li>
<li>Reading and writing 64-bit integers</li>
<li>Reading geometry columns from a PostGIS database</li>
<li>Handling of duplicate column names</li>
<li>New helpers in <em>DBI</em></li>
<li>Reusing code across backends</li>
</ul>
<p>I conclude with an outlook on things left to do.</p>
<section id="release-of-rpostgres-and-rmariadb" class="level2">
<h2 class="anchored" data-anchor-id="release-of-rpostgres-and-rmariadb">Release of <em>RPostgres</em> and <em>RMariaDB</em></h2>
<p>The DBI specification has been formulated in the preceding R consortium project, ‚ÄúImproving DBI‚Äù. It is both an automated test suite and a human-readable description of behavior, implemented in the <em>DBItest</em> package. For this project, I extended this specification and could also use it to implement <em>RPostgres</em> and <em>RMariaDB</em>: for once, test-driven development was pure pleasure, because the tests were already there!</p>
<p>I took over maintenance of the <em>RPostgres</em> and <em>RMariaDB</em> packages, which are complete rewrites of the <em>RPostgreSQL</em> and <em>RMySQL</em> packages, respectively. These packages use C++ (with <em>Rcpp</em>) as glue between R and the native database libraries. A reimplementation and release under a different name has made it much easier to fully conform to the DBI specification: only listing temporary tables and casting to blob or character is not supported by <em>RMariaDB</em> (due to a limitation of the DBMS), all other parts of the specification are fully covered.</p>
<p>Projects that use <em>RPostgreSQL</em> or <em>RMySQL</em> can continue to do so, or switch to the new backends at their own pace (which likely requires some changes to the code). For new projects I recommend <em>RPostgres</em> or <em>RMariaDB</em> to take advantage of the thorougly tested codebases and of the consistency across backends.</p>
</section>
<section id="schema-support" class="level2">
<h2 class="anchored" data-anchor-id="schema-support">Schema support</h2>
<p>Consistent access of tables in database schemas was planned for the ‚ÄúImproving DBI‚Äù project already, but I have implemented it only recently. It felt safer to see how the interface works on three backends, as opposed to implementing it for just <em>RSQLite</em> and then perhaps having to adapt it.</p>
<p>The new <code>Id()</code> function constructs identifiers. All arguments must be named, yet <em>DBI</em> doesn‚Äôt specify the argument names, because DBMS have an inconsistent notion of namespaces. The objects returned by <code>Id()</code> are ‚Äúdumb‚Äù, they gain meaning only when used in methods such as <code>dbQuoteIdentifier()</code> or <code>dbWriteTable()</code>.</p>
<p>For listing database objects in schemas, the new <code>dbListObjects()</code> generic can be used. It returns a data frame that contains identifiers (like those created by the <code>Id()</code> function) and a flag that indicates if the identifier is complete (i.e., pointing to a table or view) or a prefix. Incomplete identifiers can be passed to <code>dbListObjects()</code> again, which allows traversing the tree of database objects.</p>
<p>The following example assumes a schema <code>my_schema</code>. A table named <code>my_table</code> is created in this schema, objects are listed, and the table is read again.</p>
<pre><code>library(RPostgres)
pg_conn &lt;- dbConnect(Postgres())

table_name &lt;- Id(schema = "my_schema", table = "my_table")
table_name

## &lt;Id&gt; schema = my_schema, table = my_table

data &lt;- data.frame(a = 1:3, b = letters[1:3])
dbWriteTable(pg_conn, table_name, data)

dbListObjects(pg_conn)

##                               table is_prefix
## 1    &lt;Id&gt; table = geography_columns     FALSE
## 2     &lt;Id&gt; table = geometry_columns     FALSE
## 3      &lt;Id&gt; table = spatial_ref_sys     FALSE
## 4       &lt;Id&gt; table = raster_columns     FALSE
## 5     &lt;Id&gt; table = raster_overviews     FALSE
## 6             &lt;Id&gt; table = topology     FALSE
## 7                &lt;Id&gt; table = layer     FALSE
## 8                 &lt;Id&gt; table = temp     FALSE
## 9            &lt;Id&gt; schema = topology      TRUE
## 10          &lt;Id&gt; schema = my_schema      TRUE
## 11 &lt;Id&gt; schema = information_schema      TRUE
## 12         &lt;Id&gt; schema = pg_catalog      TRUE
## 13             &lt;Id&gt; schema = public      TRUE

dbListObjects(
  pg_conn,
  prefix = Id(schema = "my_schema")
)

##                                       table is_prefix
## 1 &lt;Id&gt; schema = my_schema, table = my_table     FALSE

dbReadTable(pg_conn, table_name)

##   a b
## 1 1 a
## 2 2 b
## 3 3 c</code></pre>
<p>In addition to <code>dbReadTable()</code> and <code>dbWriteTable()</code>, also <code>dbExistsTable()</code> and <code>dbRemoveTable()</code> and the new <code>dbCreateTable()</code> and <code>dbAppendTable()</code> (see below) support an <code>Id()</code> object as table name. The <code>dbQuoteIdentifier()</code> method converts these objects to SQL strings. Some operations (e.g.&nbsp;checking if a table exists) require the inverse, the new <code>dbUnquoteIdentifier()</code> generic takes care of converting valid SQL identifiers to (a list of) <code>Id()</code> objects:</p>
<pre><code>quoted &lt;- dbQuoteIdentifier(pg_conn, table_name)
quoted

## &lt;SQL&gt; "my_schema"."my_table"

dbUnquoteIdentifier(pg_conn, quoted)

## [[1]]
## &lt;Id&gt; schema = my_schema, table = my_table</code></pre>
<p>The new methods work consistently across backends, only <em>RSQLite</em> is currently restricted to the default schema. (Schemas in <em>RSQLite</em> are created by attaching another database, this use case seemed rather exotic but can be supported with the new infrastructure.)</p>
</section>
<section id="quoting-literal-values" class="level2">
<h2 class="anchored" data-anchor-id="quoting-literal-values">Quoting literal values</h2>
<p>When working on the database backends, it has become apparent that quoting strings and identifiers isn‚Äôt quite enough. Now there is a way to quote arbitrary values, i.e.&nbsp;convert them to a string that can be pasted into an SQL query:</p>
<pre><code>library(RSQLite)
sqlite_conn &lt;- dbConnect(SQLite())

library(RMariaDB)
mariadb_conn &lt;- dbConnect(MariaDB(), dbname = "test")

dbQuoteLiteral(sqlite_conn, 1.5)

## &lt;SQL&gt; 1.5

dbQuoteLiteral(mariadb_conn, 1.5)

## &lt;SQL&gt; 1.5

dbQuoteLiteral(pg_conn, 1.5)

## &lt;SQL&gt; 1.5::float8

dbQuoteLiteral(mariadb_conn, Sys.time())

## &lt;SQL&gt; '20180501204025'

dbQuoteLiteral(pg_conn, Sys.time())

## &lt;SQL&gt; '2018-05-01 22:40:25'::timestamp</code></pre>
<p>The default implementation works for ANSI SQL compliant DBMS, the method for <em>RPostgres</em> takes advantage of the <code>::</code> casting operator as seen in the examples.</p>
</section>
<section id="more-fine-grained-creation-of-tables" class="level2">
<h2 class="anchored" data-anchor-id="more-fine-grained-creation-of-tables">More fine-grained creation of tables</h2>
<p><em>DBI</em> supports storing data frames as tables in the database via <code>dbWriteTable()</code>. This operation consists of multiple steps:</p>
<ul>
<li>Checking if a table of this name exists, if yes:
<ul>
<li>If <code>overwrite = TRUE</code>, removing the table</li>
<li>If not, throwing an error</li>
</ul></li>
<li>Creating the table with the correct field structure</li>
<li>Preparing the data for writing</li>
<li>Writing the data</li>
</ul>
<p>To reduce complexity and allow for more options without cluttering the argument list of <code>dbWriteTable()</code>, <em>DBI</em> now provides generics for the individual steps:</p>
<ul>
<li><p>The existing <code>dbRemoveTable()</code> generic has been extended with <code>temporary</code> and <code>fail_if_missing</code> arguments. Setting <code>temporary = TRUE</code> makes sure that only temporaries are removed. By default, trying to remove a table that doesn‚Äôt exist fails, setting <code>fail_if_missing = FALSE</code> changes this behavior to a silent success.</p></li>
<li><p>The new <code>dbCreateTable()</code> generic accepts a data frame or a character vector of DBMS data types and creates a table in the database. It builds upon the existing <code>sqlCreateTable()</code> generic and also supports the <code>temporary</code> argument. If a table by that name already exists, an error is raised.</p></li>
<li><p>The new <code>dbAppendTable()</code> generic uses a prepared statement (created via <code>sqlAppendTableTemplate()</code>) to efficiently insert rows into the database. This avoids the internal overhead of converting values to SQL literals.</p></li>
</ul>
<p>The following example shows the creation and population of a table with the new methods.</p>
<pre><code>table_name

## &lt;Id&gt; schema = my_schema, table = my_table

dbRemoveTable(pg_conn, table_name, fail_if_missing = FALSE)

dbCreateTable(pg_conn, table_name, c(a = "int8", b = "float8"))

dbAppendTable(pg_conn, table_name, data.frame(a = 1:3, b = 1:3))

## [1] 3

str(dbReadTable(pg_conn, table_name))

## 'data.frame':    3 obs. of  2 variables:
##  $ a:integer64 1 2 3 
##  $ b: num  1 2 3</code></pre>
<p>The <code>dbWriteTable()</code> methods in the three backends have been adapted to use the new methods.</p>
</section>
<section id="support-for-64-bit-integers" class="level2">
<h2 class="anchored" data-anchor-id="support-for-64-bit-integers">Support for 64-bit integers</h2>
<p>As seen in the previous example, 64-bit integers can be read from the database. The three backends <em>RSQLite</em>, <em>RPostgres</em> and <em>RMariaDB</em> now also support writing 64-bit integers via the <em>bit64</em> package:</p>
<pre><code>data &lt;- data.frame(a = bit64::as.integer64(4:6), b = 4:6)
dbAppendTable(pg_conn, table_name, data)

## [1] 3

str(dbReadTable(pg_conn, table_name))

## 'data.frame':    6 obs. of  2 variables:
##  $ a:integer64 1 2 3 4 5 6 
##  $ b: num  1 2 3 4 5 6</code></pre>
<p>Because R still lacks support for native 64-bit integers, the <em>bit64</em> package feels like the best compromise: the returned values can be computed on, or coerced to <code>integer</code>, <code>numeric</code> or even <code>character</code> depending on the application. In some cases, it may be useful to always coerce. This is where the new <code>bigint</code> argument to <code>dbConnect()</code> helps:</p>
<pre><code>pg_conn_int &lt;- dbConnect(Postgres(), bigint = "integer")
str(dbReadTable(pg_conn_int, table_name))

## 'data.frame':    6 obs. of  2 variables:
##  $ a: int  1 2 3 4 5 6
##  $ b: num  1 2 3 4 5 6

pg_conn_num &lt;- dbConnect(Postgres(), bigint = "numeric")
str(dbReadTable(pg_conn_num, table_name))

## 'data.frame':    6 obs. of  2 variables:
##  $ a: num  1 2 3 4 5 6
##  $ b: num  1 2 3 4 5 6

pg_conn_chr &lt;- dbConnect(Postgres(), bigint = "character")
str(dbReadTable(pg_conn_chr, table_name))

## 'data.frame':    6 obs. of  2 variables:
##  $ a: chr  "1" "2" "3" "4" ...
##  $ b: num  1 2 3 4 5 6</code></pre>
<p>The <code>bigint</code> argument works consistently across the three backends <em>RSQLite</em>, <em>RPostgres</em> and <em>RMariaDB</em>, the DBI specification contains a test for and a description of the requirements.</p>
</section>
<section id="geometry-columns" class="level2">
<h2 class="anchored" data-anchor-id="geometry-columns">Geometry columns</h2>
<p>PostgreSQL has support for user-defined data types, this is used e.g.&nbsp;by PostGIS to store spatial data. Before, user-defined data types were returned as character values, with a warning. Thanks to a contribution by Etienne B. Racine:</p>
<ul>
<li>the warnings are gone,</li>
<li>the user-defined data type is now stored in an attribute of the column in the data frame,</li>
<li>details on columns with user-defined data types are available in <code>dbColumnInfo()</code>.</li>
</ul>
<!-- -->
<pre><code>dbCreateTable(
  pg_conn,
  "geom_test",
  c(id = "int4", geom = "geometry(Point, 4326)")
)

data &lt;- data.frame(
  id = 1,
  geom = "SRID=4326;POINT(-71.060316 48.432044)",
  stringsAsFactors = FALSE
)
dbAppendTable(pg_conn, "geom_test", data)

## [1] 1

str(dbReadTable(pg_conn, "geom_test"))

## 'data.frame':    1 obs. of  2 variables:
##  $ id  : int 1
##  $ geom:Class 'pq_geometry'  chr "0101000020E61000003CDBA337DCC351C06D37C1374D374840"

res &lt;- dbSendQuery(pg_conn, "SELECT * FROM geom_test")
dbColumnInfo(res)

##   name      type   .oid .known .typname
## 1   id   integer     23   TRUE     int4
## 2 geom character 101529  FALSE geometry

dbClearResult(res)</code></pre>
<p>Special support for geometry columns is currently available only in <em>RPostgres</em>.</p>
</section>
<section id="duplicate-column-names" class="level2">
<h2 class="anchored" data-anchor-id="duplicate-column-names">Duplicate column names</h2>
<p>The specification has been extended to disallow duplicate, empty or <code>NA</code> column names. The deduplication used by our three backends is similar to that used by <code>tibble::set_tidy_names()</code>, but the DBI specification does not require any particular deduplication mechanism. Syntactic names aren‚Äôt required either:</p>
<pre><code>dbGetQuery(sqlite_conn, "SELECT 1, 2, 3")

##   1 2 3
## 1 1 2 3

dbGetQuery(sqlite_conn, "SELECT 1 AS a, 2 AS a, 3 AS `a..2`")

##   a a..2 a..3
## 1 1    2    3

dbGetQuery(mariadb_conn, "SELECT 1, 2, 3")

##   1 2 3
## 1 1 2 3

dbGetQuery(mariadb_conn, "SELECT 1 AS a, 2 AS a, 3 AS `a..2`")

##   a a..2 a..3
## 1 1    2    3

dbGetQuery(pg_conn, "SELECT 1, 2, 3")

##   ?column? ?column?..2 ?column?..3
## 1        1           2           3

dbGetQuery(pg_conn, 'SELECT 1 AS a, 2 AS a, 3 AS "a..2"')

##   a a..2 a..3
## 1 1    2    3</code></pre>
</section>
<section id="helpers" class="level2">
<h2 class="anchored" data-anchor-id="helpers">Helpers</h2>
<p>Two little helper generics have been added.</p>
<p>The new <code>dbIsReadOnly()</code> generic (contributed by Anh Le) should return <code>TRUE</code> for a read-only connection. This is not part of the specification yet.</p>
<p>The <code>dbCanConnect()</code> tests a set of connection parameters. The default implementation simply connects and then disconnects upon success. For DBMS that can provide more efficient methods of checking connectivity, a lighter-weight implementation of this method may give a better experience.</p>
<p>None of the three backends currently provide specialized implementations for these generics.</p>
</section>
<section id="code-reuse" class="level2">
<h2 class="anchored" data-anchor-id="code-reuse">Code reuse</h2>
<p>I have made some efforts to extract common C++ classes for assembling data frames and prepare them for reuse. The C++ source code for the three backends contains files prefixed with <code>Db</code>, these are almost identical across the backends. The planned packaging into the <em>RKazam</em> package had to yield to higher-priority features described above.</p>
<p>The situation in the R code is similar: I have found myself copy-pasting code from one backend into another because I didn‚Äôt feel it‚Äôs ready (or standardized enough) to be included in the <em>DBI</em> package.</p>
<p>For both use cases, a code reuse strategy based on copying/updating template files or reconciling files may be more robust than the traditional importing mechanisms offered by R.</p>
</section>
<section id="outlook" class="level2">
<h2 class="anchored" data-anchor-id="outlook">Outlook</h2>
<p>The upcoming CRAN release of <em>DBI</em>, <em>DBItest</em> and the three backends <em>RSQLite</em>, <em>RMariaDB</em> and <em>RPostgres</em> are an important milestone. Stability is important when more and more users and projects use the new backends. Nevertheless, I see quite a few potential improvements that so far were out of scope of the ‚ÄúImproving DBI‚Äù and ‚ÄúEstablishing DBI‚Äù projects:</p>
<ol type="1">
<li><p>Support running the test suite locally, to validate adherence to DBI for a particular installation.</p></li>
<li><p>Consistent fast data import.</p></li>
<li><p>Consistent query placeholders (currently <code>$1</code> for <em>RPostgres</em> and <code>?</code> for many other backends).</p></li>
<li><p>Support for arbitrary data types via hooks.</p></li>
<li><p>Assistance with installation problems on specific architectures, or connectivity problems with certain databases, or other specific issues.</p></li>
<li><p>Rework the internal architecture of <em>DBItest</em> to simplify locating test failures.</p></li>
<li><p>Improve the <a href="https://r-dbi.org" class="uri">https://r-dbi.org</a> website.</p></li>
<li><p>Non-blocking queries.</p></li>
</ol>
<p>I have submitted another proposal to the R Consortium, hoping to receive support with these and other issues.</p>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>I‚Äôd like to thank the R Consortium for their generous financial support. Many thanks to the numerous contributors who helped make the past two projects a success.</p>


</section>

 ]]></description>
  <guid>https://r-dbi.org/blog/dbi-2-final/</guid>
  <pubDate>Tue, 01 May 2018 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Connecting to open source databases</title>
  <dc:creator>Kirill M√ºller</dc:creator>
  <link>https://r-dbi.org/blog/rstudio-conf/</link>
  <description><![CDATA[ 




<section id="link-to-video" class="level2">
<h2 class="anchored" data-anchor-id="link-to-video">Link to video</h2>
<p>
<a href="https://posit.co/resources/videos/connecting-to-open-source-databases/?wvideo=yf1vdwugk5"><img src="https://embed-ssl.wistia.com/deliveries/6cc6be1f7e21a6ecd6640c0068ecd86a94c235d0.jpg?image_play_button_size=2x&amp;image_crop_resized=960x540&amp;image_play_button=1&amp;image_play_button_color=4287c7e0" style="width: 400px; height: 225px;" width="400" height="225"></a>
</p>
<p>
<a href="https://posit.co/resources/videos/connecting-to-open-source-databases/?wvideo=yf1vdwugk5">Connecting to open source databases - Posit</a>
</p>
</section>
<section id="slides" class="level2">
<h2 class="anchored" data-anchor-id="slides">Slides</h2>
<div style="position:relative;padding-top:56.25%;">
<p><iframe src="https://krlmlr.github.io/dbi-slides/2018-02-san-diego-rstudio-conf" frameborder="0" allowfullscreen="" style="position:absolute;top:0;left:0;width:100%;height:100%;"></iframe></p>
</div>
<p><a href="https://krlmlr.github.io/dbi-slides/2018-02-san-diego-rstudio-conf" target="_blank">Full screen version</a></p>


</section>

 ]]></description>
  <guid>https://r-dbi.org/blog/rstudio-conf/</guid>
  <pubDate>Fri, 02 Feb 2018 00:00:00 GMT</pubDate>
</item>
<item>
  <title></title>
  <dc:creator>Kirill M√ºller</dc:creator>
  <link>https://r-dbi.org/blog/dbi-1-final/</link>
  <description><![CDATA[ 




<p>The ‚ÄúImproving DBI‚Äù project, funded by the R consortium, started about a year ago. It includes</p>
<ol type="1">
<li>the definition and implementation of a testable specification for DBI,</li>
<li>making <code>RSQLite</code> fully compliant to the new specification.</li>
</ol>
<p>Besides the established <code>DBI</code> and <code>RSQLite</code> packages, I have spent a lot of time on the new <code>DBItest</code> package. Final updates to these packages will be pushed to CRAN end of May this year, to give downstream maintainers some time to accommodate.</p>
<p>The follow-up project ‚ÄúEstablishing DBI‚Äù will focus on fully DBI-compliant backends for MySQL/MariaDB and PostgreSQL, and on minor updates to the specs where appropriate.</p>
<section id="dbitest-specification" class="level2">
<h2 class="anchored" data-anchor-id="dbitest-specification"><code>DBItest</code>: Specification</h2>
<p>A comprehensive backend-agnostic test suite for DBI backends is provided by the new <code>DBItest</code> package. When the project started, it was merely a collection of test cases. I have considerably expanded the test cases and provided a human-readable description for each, using literate programming techniques powered by <code>roxygen2</code>. The <code>DBI</code> package weaves these chunks of text to a single document that describes all test cases covered by the test suite, the textual <em>DBI specification</em>. This approach ensures that further updates to the specification are reflected in both the automatic tests and the text.</p>
<p>This package is aimed at backend implementers, who now can programmatically check with very little effort if their DBI backend conforms to the DBI specification. The verification can be integrated in the automated tests which are run as part of R‚Äôs package check mechanism in <code>R CMD check</code>. The <code>odbc</code> package, a new DBI-compliant interface to the ODBC interface, has been using <code>DBItest</code> from day one to enable test-driven development. The <code>bigrquery</code> package is another user of <code>DBItest</code>.</p>
<p>Because not all DBMS support all aspects of DBI, the <code>DBItest</code> package allows to restrict which parts of the specification are tested, or ‚Äútweak‚Äù certain aspects of the tests, e.g., the format of placeholders in parametrized queries. Adapting to other DBMS may require more work due to subtle differences in the implementation of SQL between various DBMS.</p>
</section>
<section id="dbi-definition" class="level2">
<h2 class="anchored" data-anchor-id="dbi-definition"><code>DBI</code>: Definition</h2>
<p>This package has been around since 2001, it defines the actual <em>DataBase Interface</em> in R. I have taken over maintenance, and released versions 0.4-1, 0.5-1, and 0.6-1, with release of version 0.7 pending.</p>
<p>The most prominent change in this package is, of course, the textual <a href="https://cran.r-project.org/web/packages/DBI/vignettes/spec.html">DBI specification</a>, which is included as an HTML vignette in the package. The documentation for the various methods defined by <code>DBI</code> is obtained directly from the specification. These help topics are combined in a sensible order to a single, self-contained document. This format is useful for both DBI users and implementers: users can look up the behavior of a method directly from its help page, and implementers can browse a comprehensive document that describes all aspects of the interface. I have also revised the description and the examples for all help topics.</p>
<p>Other changes include:</p>
<ul>
<li>the definition of new generics <code>dbSendStatement()</code> and <code>dbExecute()</code>, for backends that distinguish between queries that return a table and statements that manipulate data,</li>
<li>the new <code>dbWithTransaction()</code> generic and the <code>dbBreak()</code> helper function, thanks Barbara Borges Ribero,</li>
<li>improved or new default implementations for methods like <code>dbGetQuery()</code>, <code>dbReadTable()</code>, <code>dbQuoteString()</code>, <code>dbQuoteIdentifier()</code>,</li>
<li>internal changes that allow methods that don‚Äôt have a meaningful return value to return silently,</li>
<li>translation of a helper function from C++ to R, to remove the dependency on <code>Rcpp</code> (thanks Hannes M√ºhleisen).</li>
</ul>
<p>Fortunately, none of the changes seemed to have introduced any major regressions with downstream packages. The <a href="https://github.com/rstats-db/DBI/blob/master/NEWS.md">news</a> contain a comprehensive list of changes.</p>
</section>
<section id="rsqlite-implementation" class="level2">
<h2 class="anchored" data-anchor-id="rsqlite-implementation"><code>RSQLite</code>: Implementation</h2>
<p><code>RSQLite</code> 1.1-2 is a complete rewrite of the original C implementation. Before focusing on compliance to the new DBI specification, it was important to assert compatibility to more than 100 packages on CRAN and Bioconductor that use <code>RSQLite</code>. These packages revealed many usage patterns that were difficult to foresee. Most of these usage patterns are supported in version 1.1-2, the more esoteric ones (such as supplying an <code>integer</code> where a <code>logical</code> is required) trigger a warning.</p>
<p>Several rounds of ‚Äúrevdep checking‚Äù were necessary before most packages showed no difference in their check output compared to the original implementation. The downstream maintainers and the Bioconductor team were very supportive, and helped spotting functional and performance regressions during the release process. Two point releases were necessary to finally achieve a stable state.</p>
<p>Supporting 64-bit integers also was trickier than anticipated. There is no built-in way to represent 64-bit integers in R. The <code>bit64</code> package works around this limitation by using a <code>numeric</code> vector as storage, which also happens to use 8 bytes per element, and providing coercion functions. But when an integer column is fetched, it cannot be foreseen if a 64-bit value will occur in the result, and smaller integers must use R‚Äôs built-in <code>integer</code> type. For this purpose, an efficient data structure for collecting vectors, which is capable of changing the data type on the fly, has been implemented in C++. This data structure will be useful for many other DBI backends that need support for a 64-bit integer data type, and will be ported to the <code>RKazam</code> package in the follow-up project.</p>
<p>Once the DBI specification was completed, the process of making <code>RSQLite</code> compliant was easy: enable one of the disabled tests, fix the code, make sure all tests pass, rinse, and repeat. If you haven‚Äôt tried it, I seriosly recommend test-driven development, especially when the tests are already implemented.</p>
<p>The upcoming release of <code>RSQLite</code> 2.0 will require stronger adherence to the DBI specification also from callers. Where possible I tried to maintain backward compatibility, but in some cases breaks were inevitable because otherwise I‚Äôd have had to introduce far too many exceptions and corner cases in the DBI spec. For instance, row names are no longer included by default when writing or reading tables. The original behavior can be reenabled by calling <code>pkgconfig::set_config()</code>, so that packages or scripts that rely on row names continue to work as before. (The setting is active for the duration of the session, but only for the caller that has called <code>pkgconfig::set_config()</code>.) I‚Äôm happy to include compatibility switches for other breaking changes if necessary and desired, to achieve both adherence to the specs and compatibility with existing behavior.</p>
<p>A comprehensive list of changes can be found in the <a href="https://github.com/rstats-db/RSQLite/blob/master/NEWS.md">news</a>.</p>
</section>
<section id="other-bits-and-pieces" class="level2">
<h2 class="anchored" data-anchor-id="other-bits-and-pieces">Other bits and pieces</h2>
<p>The <code>RKazam</code> package is a ready-to-use boilerplate for a DBI backend, named after the hypothetical DBMS used as example in a DBI vignette. It already ‚Äúpasses‚Äù all tests of the <code>DBItest</code> package, mostly by calling a function that skips the current test. Starting a DBI backend from scratch requires only copying and renaming the package‚Äôs code.</p>
<p>R has limited support for time-of-day data. The <code>hms</code> package aims at filling this gap. It will be useful especially in the follow-up project, because SQLite doesn‚Äôt have an intrinsic type for time-of-day data, unlike many other DBMS.</p>
</section>
<section id="next-steps" class="level2">
<h2 class="anchored" data-anchor-id="next-steps">Next steps</h2>
<p>The ensemble CRAN release of the three packages <code>DBI</code>, <code>DBItest</code> and <code>RSQLite</code> will occur in parallel to the startup phase for the ‚ÄúEstablishing DBI‚Äù follow-up project. This project consists of:</p>
<ul>
<li>Fully DBI compatible backends for MySQL/MariaDB and Postgres</li>
<li>A backend-agnostic C++ data structure to collect column data in the <code>RKazam</code> package</li>
<li>Support for spatial data</li>
</ul>
<p>In addition, it will contain an update to the DBI specification, mostly concerning support for schemas and for querying the structure of the table returned for a query. Targeting three DBMS instead of one will help properly specify these two particularly tricky parts of DBI. I‚Äôm happy to take further feedback from users and backend implementers towards further improvement of the DBI specification.</p>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>Many thanks to the R Consortium, who has sponsored this project, and to the many contributors who have spotted problems, suggested improvements, submitted pull requests, or otherwise helped make this project a great success. In particular, I‚Äôd like to thank Hadley Wickham, who suggested the idea, supported initial development of the <code>DBItest</code> package, and provided helpful feedback; and Christoph H√∂sler, Hannes M√ºhleisen, Imanuel Costigan, Jim Hester, Marcel Boldt, and <span class="citation" data-cites="thrasibule">@thrasibule</span> for using it and contributing to it. I enjoyed working on this project, looking forward to ‚ÄúEstablishing DBI‚Äù!</p>


</section>

 ]]></description>
  <guid>https://r-dbi.org/blog/dbi-1-final/</guid>
  <pubDate>Mon, 15 May 2017 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Halfway through ‚ÄúImproving DBI‚Äù</title>
  <dc:creator>Kirill M√ºller</dc:creator>
  <link>https://r-dbi.org/blog/dbi-1-halfway/</link>
  <description><![CDATA[ 




<p>In early 2016 the R Consortium partially accepted my ‚ÄúImproving DBI‚Äù proposal. An important part is the design and implementation of a testable DBI specification. Initially I also proposed to make three DBI backends to open-source databases engines (RSQLite, RMySQL, and RPostgres) compatible to the new DBI specification, but funding allows to work on only one DBI backend. I chose RSQLite for a number of reasons:</p>
<ul>
<li>It is a very important package, judging by the number of reverse CRAN and Bioconductor dependencies</li>
<li>It‚Äôs easy to work with, because everything (including the database engine) is bundled with the package</li>
<li>It seemed to be the most advanced package, closest to the (yet to be completed) DBI specification</li>
<li>An <a href="https://twitter.com/krlmlr/status/712950420969283584">informal Twitter poll</a> supports this decision by a tiny margin</li>
</ul>
<p>The project has reached an important milestone, with the release of RSQLite 1.1. This post reports the progress achieved so far, and outlines the next steps.</p>
<section id="rsqlite" class="level2">
<h2 class="anchored" data-anchor-id="rsqlite">RSQLite</h2>
<p>While the RSQLite API has changed very little (hence the minor version update), it includes a complete rewrite of the original 1.0.0 sources in C++. This has considerably simplified the code, which makes future maintenance easier, and allows us to take advantage of the more sophisticated memory management tools available in Rcpp, which help protect against memory leaks and crashes.</p>
<p>RSQLite 1.1 brings a number of improvements:</p>
<ul>
<li>New strategy for prepared queries: Create a prepared query with <code>dbSendQuery()</code> or <code>dbSendStatement()</code> and bind values with <code>dbBind()</code>. This allows you to efficiently re-execute the same query/statement with different parameter values iteratively (by calling <code>dbBind()</code> several times) or in a batch (by calling <code>dbBind()</code> once with a data-frame-like object).</li>
<li>Support for inline parametrised queries via the param argument to <code>dbSendQuery()</code>, <code>dbGetQuery()</code>, <code>dbSendStatement()</code> and <code>dbExecute()</code>, to protect from <a href="https://xkcd.com/327/">SQL injection</a>.</li>
<li>The existing methods <code>dbSendPreparedQuery()</code> and <code>dbGetPreparedQuery()</code> have been soft-deprecated, because the new API is more versatile, more consistent and stricter about parameter validation.</li>
<li>Using UTF8 for queries and parameters: this mean that non-English data should just work without any additional intervention.</li>
<li>Improved mapping between SQLite‚Äôs cell-types and R‚Äôs column-types.</li>
</ul>
<p>See the <a href="https://github.com/r-dbi/RSQLite/releases/tag/v1.1">release notes</a> for further changes.</p>
<p>The rewrite was implemented by Hadley Wickham before the ‚ÄúImproving DBI‚Äù project started, and has been available for a long time on GitHub. Nevertheless, the CRAN release has proven much more challenging than anticipated, because so many CRAN and Bioconductor packages import it. (Maintainers of reverse dependencies might remember multiple e-mails where I was threatening to release RSQLite ‚Äúfor real‚Äù.) My aim was to break as little existing code as possible. After numerous rounds of revdep-checking and improving RSQLite, I‚Äôm proud to report that the vast majority of reverse dependencies pass their checks just as well (and as quickly!) as they did with v1.0.0. Most tests from v1.0.0 are still present in the current codebase. This means that non-packaged code also has a good chance to work unchanged. I‚Äôm happy to work with package maintainers or users whose code breaks after the update.</p>
<p>DBI</p>
<hr>
<p>I have also released several DBI updates to CRAN, mostly to introduce new generics such as <code>dbBind()</code> (for parametrized/prepared queries) or <code>dbSendStatement()</code> and <code>dbExecute()</code> (for statements which don‚Äôt return data). The definition of a formal DBI specification is part of the project, a <a href="https://dbi.r-dbi.org/articles/spec.html">formatted version</a> is updated continuously.</p>
</section>
<section id="dbitest" class="level2">
<h2 class="anchored" data-anchor-id="dbitest">DBItest</h2>
<p>In addition to the textual specification in the DBI package, the DBItest package provides backend independent tests for DBI packages. It can be easily used by package authors to ensure that they follow the DBI specification. This is important because it allows you to take code that works with one DBI backend and easily switch to a different backend (providing that they both support the same SQL dialect). Literate programming techniques using advanced features of roxygen2 help keeping both code and textual specifications in close proximity, so that amendments to the text can be easily tracked back to changes of the test code, and vice versa.</p>
</section>
<section id="next-steps" class="level2">
<h2 class="anchored" data-anchor-id="next-steps">Next steps</h2>
<p>The rest of the project will focus on finalizing the specification in both code and text (mostly discussed on GitHub in the issue trackers for the <a href="https://github.com/r-dbi/DBI/issues">DBI</a> and <a href="https://github.com/r-dbi/DBItest/issues">DBItest</a> projects). At least one new helper package (to handle 64-bit integer types) will be created, and DBI, DBItest, and RSQLite will see yet another release: The first two will finalize the DBI specification, and RSQLite will fully conform to it.</p>
<p>The development happens entirely on GitHub in repositories of the <a href="https://github.com/r-dbi">r-dbi</a> organization. Feel free to try out development versions of the packages found there, and to report any problems or ideas at the issue trackers.</p>


</section>

 ]]></description>
  <guid>https://r-dbi.org/blog/dbi-1-halfway/</guid>
  <pubDate>Tue, 06 Dec 2016 00:00:00 GMT</pubDate>
</item>
</channel>
</rss>
